<!DOCTYPE html>
<html>
  <head>
    <title>Distributed systems for fun and profit</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
@font-face {
  font-family: 'Droid Sans';
  font-style: normal;
  font-weight: normal;
  src: local('Droid Sans'), local('DroidSans'), url('DroidSans.woff') format('woff');
}
</style>
<script src="assets/jquery-1.6.1.min.js"></script>



<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-26716650-2', 'mixu.net');
  ga('send', 'pageview');
</script>
  <link type="text/css" rel="stylesheet" href="assets/ebook.css"/></head>
<body>
  <div id="wrapper">
    <div class="header">
      <div id="brand">
        <h1 style="color: white; background: #D82545; display: inline-block; padding: 6px;">Distributed systems</h1>
        <p>for fun and profit</p>
      </div>
      <div id="navi">
        <form class="search" action="http://www.google.com/search">
          <input type="hidden" name="as_sitesearch" value="singlepageappbook.com">
          <input type="text" name="as_q" value="" class="search_field">
          <input type="submit" value="Search" class="search_btn">
        </form>
      </div>
    </div>


    <div class="clear">
      <hr>
    </div>
    <!-- index-insert -->

    <div class="header nav">
      <p><a href="index.html">Previous Chapter</a> | <a href="index.html">Home</a> | <a href="index.html">Next Chapter</a></p>

    </div>
    <div class="clear">
      <hr>
    </div>

     <!-- Main -->

    <div id="main">
      <div id="content" class="post">
<a name="index"></a><h2>Introduction</h2>
<p>I wanted a text that would bring together the ideas behind many of the more recent distributed systems - systems such as Amazon&#39;s Dynamo, Google&#39;s BigTable and MapReduce, Apache&#39;s Hadoop and so on.</p>
<p>In this text I&#39;ve tried to provide a more accessible introduction to distributed systems. To me, that means two things: introducing the key concepts that you will need in order to <a href="https://www.google.com/search?q=super+cool+ski+instructor">have a good time</a> reading more serious texts, and providing a narrative that covers things in enough detail that you get a gist of what&#39;s going on without getting stuck on details. It&#39;s 2013, you&#39;ve got the Internet, and you can selectively read more about the topics you find most interesting.</p>
<p>In my view, much of distributed programming is about dealing with the implications of two consequences of distribution:</p>
<ul class="list">
<li>that information travels at the speed of light</li>
<li>that independent things fail independently*</li>
</ul>
<p>In other words, that the core of distributed programming is dealing with distance (duh!) and having more than one thing (duh!). These constraints define a space of possible system designs, and my hope is that after reading this you&#39;ll have a better sense of how distance, time and consistency models interact.</p>
<p>This text is focused on distributed programming and systems concepts you&#39;ll need to understand commercial systems in the data center. It would be madness to attempt to cover everything. You&#39;ll learn many key protocols and algorithms (covering, for example, many of the most cited papers in the discipline), including some new exciting ways to look at eventual consistency that haven&#39;t still made it into college textbooks - such as CRDTs and the CALM theorem.</p>
<p>I hope you like it! If you want to say thanks, follow me on <a href="https://github.com/mixu/">Github</a> (or <a href="http://twitter.com/mikitotakada">Twitter</a>). And if you spot an error, <a href="https://github.com/mixu/distsysbook/issues">file a pull request on Github</a>.</p>
<hr>
<h1>1. Basics</h1>
<p><a href="#intro">The first chapter</a> covers distributed systems at a high level by introducing a number of important terms and concepts. It covers high level goals, such as scalability, availability, performance, latency and fault tolerance; how those are hard to achieve, and how abstractions and models as well as partitioning and replication come into play.</p>
<h1>2. Up and down the level of abstraction</h1>
<p><a href="#abstractions">The second chapter</a> dives deeper into abstractions and impossibility results. It starts with a Nietzsche quote, and then introduces system models and the many assumptions that are made in a typical system model. It then discusses the CAP theorem and summarizes the FLP impossibility result. It then turns to the implications of the CAP theorem, one of which is that one ought to explore other consistency models. A number of consistency models are then discussed.</p>
<h1>3. Time and order</h1>
<p>A big part of understanding distributed systems is about understanding time and order.  To the extent that we fail to understand and model time, our systems will fail. <a href="#time">The third chapter</a> discusses time and order, and clocks as well as the various uses of time, order and clocks (such as vector clocks and failure detectors).</p>
<h1>4. Replication: preventing divergence</h1>
<p>The <a href="#replication">fourth chapter</a> introduces the replication problem, and the two basic ways in which it can be performed. It turns out that most of the relevant characteristics can be discussed with just this simple characterization. Then, replication methods for maintaining single-copy consistency are discussed from the least fault tolerant (2PC) to Paxos.</p>
<h1>5. Replication: accepting divergence</h1>
<p>The <a href="#eventual">fifth chapter</a> discussed replication with weak consistency guarantees. It introduces a basic reconciliation scenario, where partitioned replicas attempt to reach agreement. It then discusses Amazon&#39;s Dynamo as an example of a system design with weak consistency guarantees. Finally, two perspectives on disorderly programming are discussed: CRDTs and the CALM theorem.</p>
<h1>Appendix</h1>
<p><a href="#appendix">The appendix</a> covers recommendations for further reading.</p>
<hr>
<p class="footnote">*: This is a <a href="http://en.wikipedia.org/wiki/Statistical_independence">lie</a>. <a href="http://blog.empathybox.com/post/19574936361/getting-real-about-distributed-system-reliability">This post by Jay Kreps elaborates</a>.
</p>
<div style="page-break-after: always;"></div><a name="intro"></a><h1>1. Distributed systems at a high level</h1>
<blockquote>
<p>Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers.</p>
</blockquote>
<p>There are two basic tasks that any computer system needs to accomplish:</p>
<ul class="list">
<li>storage and</li>
<li>computation</li>
</ul>
<p>Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers - usually, because the problem no longer fits on a single computer.</p>
<p>Nothing really demands that you use distributed systems. Given infinite money and infinite R&amp;D time, we wouldn&#39;t need distributed systems. All computation and storage could be done on a magic box - a single, incredibly fast and incredibly reliable system <em>that you pay someone else to design for you</em>.</p>
<p>However, few people have infinite resources. Hence, they have to find the right place on some real-world cost-benefit curve. At a small scale, upgrading hardware is a viable strategy. However, as problem sizes increase you will reach a point where either the hardware upgrade that allows you to solve the problem on a single node does not exist, or becomes cost-prohibitive. At that point, I welcome you to the world of distributed systems.</p>
<p>It is a current reality that the best value is in mid-range, commodity hardware - as long as the maintenance costs can be kept down through fault-tolerant software.</p>
<p>Computations primarily benefit from high-end hardware to the extent to which they can replace slow network accesses with internal memory accesses. In tasks that require only small amounts of communication between nodes, the performance advantage of high-end hardware is limited.</p>
<p class="img-container"><img src="images/barroso_holzle.png" alt="cost-efficiency"></p>
<p>Even in tasks that require high amounts of communication, the performance gap between high-end and commodity hardware decreases with cluster size assuming a uniform memory access pattern across all nodes (e.g. the figure above from <a href="http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024">Barroso, Clidaras &amp; HÃ¶lzle</a>).</p>
<p>Ideally, adding a new machine would increase the performance and capacity of the system linearly. But of course this is not possible, because there is some overhead that arises due to having separate computers. Data needs to be copied around, computation tasks have to be coordinated and so on. This is why it&#39;s worthwhile to study distributed algorithms - they provide efficient solutions to specific problems, as well as guidance about what is possible, what the minimum cost of a correct implementation is, and what is impossible.</p>
<p>The focus of this text is on distributed programming and systems in a mundane, but commercially relevant setting: the data center. For example, I will not discuss specialized problems that arise from having an exotic network configuration, or that arise in a shared-memory setting. Additionally, the focus is on exploring the system design space rather than on optimizing any specific design - the latter is a topic for a much more specialized text.</p>
<h2>What we want to achieve: Scalability and other good things</h2>
<p>The way I see it, everything starts with the need to deal with size.</p>
<p>Most things are trivial at a small scale - and the same problem becomes much harder once you surpass a certain size, volume or other physically constrained thing. It&#39;s easy to lift a piece of chocolate, it&#39;s hard to lift a mountain. It&#39;s easy to count how many people are in a room, and hard to count how many people are in a country.</p>
<p>So everything starts with size - scalability. Informally speaking, in a scalable system as we move from small to large, things should not get incrementally worse. Here&#39;s another definition:</p>
<dl>
  <dt><a href="http://en.wikipedia.org/wiki/Scalability">Scalability</a></dt>
  <dd>is the ability of a system, network, or process, to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.</dd>
</dl>

<p>What is it that is growing? Well, you can measure growth in almost any terms (number of people, electricity usage etc.). But there are three particularly interesting things to look at:</p>
<ul class="list">
<li>Size scalability: adding more nodes should make the system linearly faster; growing the dataset should not increase latency</li>
<li>Geographic scalability: it should be possible to use multiple data centers to reduce the time it takes to respond to user queries, while dealing with cross-data center latency in some sensible manner.</li>
<li>Administrative scalability: adding more nodes should not increase the administrative costs of the system (e.g. the administrators-to-machines ratio).</li>
</ul>
<p>Of course, in a real system growth occurs on multiple different axes simultaneously; each metric captures just some aspect of growth.</p>
<p>A scalable system is one that continues to meet the needs of its users as scale increases. There are two particularly relevant aspects - performance and availability - which can be measured in various ways.</p>
<h3>Performance (and latency)</h3>
<dl>
  <dt><a href="http://en.wikipedia.org/wiki/Computer_performance">Performance</a></dt>
  <dd>is characterized by the amount of useful work accomplished by a computer system compared to the time and resources used.</dd>
</dl>

<p>Depending on the context, this may involve achieving one or more of the following:</p>
<ul class="list">
<li>Short response time/low latency for a given piece of work</li>
<li>High throughput (rate of processing work)</li>
<li>Low utilization of computing resource(s)</li>
</ul>
<p>There are tradeoffs involved in optimizing for any of these outcomes. For example, a system may achieve a higher throughput by processing larger batches of work thereby reducing operation overhead. The tradeoff would be longer response times for individual pieces of work due to batching.</p>
<p>I find that low latency - achieving a short response time - is the most interesting aspect of performance, because it has a strong connection with physical (rather than financial) limitations. It is harder to address latency using financial resources than the other aspects of performance.</p>
<p>There are a lot of really specific definitions for latency, but I really like the idea that the etymology of the word evokes:</p>
<dl>
  <dt>Latency</dt>
  <dd>The state of being latent; delay, a period between the initiation of something and the occurrence.</dd>
</dl>

<p>And what does it mean to be &quot;latent&quot;?</p>
<dl>
  <dt>Latent</dt>
  <dd>From Latin latens, latentis, present participle of lateo (&quot;lie hidden&quot;). Existing or present but concealed or inactive.</dd>
</dl>

<p>This definition is pretty cool, because it highlights how latency is really the time between something happened and the time it has an impact or becomes visible.</p>
<p>For example, imagine that you are infected with an airborne virus that turns people into zombies. The latent period is the time between when you became infected, and when you turn into a zombie. That&#39;s latency: the time during which something that has already happened is concealed from view.</p>
<p>Let&#39;s assume for a moment that our distributed system does just one high-level task: given a query, it takes all of the data in the system and calculates a single result. In other words, think of a distributed system as a data store with the ability to run a single deterministic computation (function) over its current content:</p>
<p><code>result = query(all data in the system)</code></p>
<p>Then, what matters for latency is not the amount of old data, but rather the speed at which new data &quot;takes effect&quot; in the system. For example, latency could be measured in terms of how long it takes for a write to become visible to readers.</p>
<p>The other key point based on this definition is that if nothing happens, there is no &quot;latent period&quot;. A system in which data doesn&#39;t change doesn&#39;t (or shouldn&#39;t) have a latency problem.</p>
<p>In a distributed system, there is a minimum latency that cannot be overcome: the speed of light limits how fast information can travel, and hardware components have a minimum latency cost incurred per operation (think RAM and hard drives but also CPUs).</p>
<p>How much that minimum latency impacts your queries depends on the nature of those queries and the physical distance the information needs to travel.</p>
<h3>Availability (and fault tolerance)</h3>
<p>The second aspect of a scalable system is availability.</p>
<dl>
  <dt><a href="http://en.wikipedia.org/wiki/High_availability">Availability</a></dt>
  <dd>the proportion of time a system is in a functioning condition. If a user cannot access the system, it is said to be unavailable. </dd>
</dl>

<p>Distributed systems allow us to achieve desirable characteristics that would be hard to accomplish on a single system. For example, a single machine cannot tolerate any failures since it either fails or doesn&#39;t.</p>
<p>Distributed systems can take a bunch of unreliable components, and build a reliable system on top of them.</p>
<p>Systems that have no redundancy can only be as available as their underlying components. Systems built with redundancy can be tolerant of partial failures and thus be more available. It is worth noting that &quot;redundant&quot; can mean different things depending on what you look at - components, servers, datacenters and so on.</p>
<p>Formulaically, availability is: <code>Availability = uptime / (uptime + downtime)</code>.</p>
<p>Availability from a technical perspective is mostly about being fault tolerant. Because the probability of a failure occurring increases with the number of components, the system should be able to compensate so as to not become less reliable as the number of components increases.</p>
<p>For example:</p>
<table>
<tr>
  <td>Availability %</td>
  <td>How much downtime is allowed per year?</td>
</tr>
<tr>
  <td>90% (&quot;one nine&quot;)</td>
  <td>More than a month</td>
</tr>
<tr>
  <td>99% (&quot;two nines&quot;)</td>
  <td>Less than 4 days</td>
</tr>
<tr>
  <td>99.9% (&quot;three nines&quot;)</td>
  <td>Less than 9 hours</td>
</tr>
<tr>
  <td>99.99% (&quot;four nines&quot;)</td>
  <td>Less than an hour</td>
</tr>
<tr>
  <td>99.999% (&quot;five nines&quot;)</td>
  <td>~ 5 minutes</td>
</tr>
<tr>
  <td>99.9999% (&quot;six nines&quot;)</td>
  <td>~ 31 seconds</td>
</tr>
</table>


<p>Availability is in some sense a much wider concept than uptime, since the availability of a service can also be affected by, say, a network outage or the company owning the service going out of business (which would be a factor which is not really relevant to fault tolerance but would still influence the availability of the system). But without knowing every single specific aspect of the system, the best we can do is design for fault tolerance.</p>
<p>What does it mean to be fault tolerant?</p>
<dl>
  <dt>Fault tolerance</dt>
  <dd>ability of a system to behave in a well-defined manner once faults occur</dd>
</dl>

<p>Fault tolerance boils down to this: define what faults you expect and then design a system or an algorithm that is tolerant of them. You can&#39;t tolerate faults you haven&#39;t considered.</p>
<h2>What prevents us from achieving good things?</h2>
<p>Distributed systems are constrained by two physical factors:</p>
<ul class="list">
<li>the number of nodes (which increases with the required storage and computation capacity)</li>
<li>the distance between nodes (information travels, at best, at the speed of light)</li>
</ul>
<p>Working within those constraints:</p>
<ul class="list">
<li>an increase in the number of independent nodes increases the probability of failure in a system (reducing availability and increasing administrative costs)</li>
<li>an increase in the number of independent nodes may increase the need for communication between nodes (reducing performance as scale increases)</li>
<li>an increase in geographic distance increases the minimum latency for communication between distant nodes (reducing performance for certain operations)</li>
</ul>
<p>Beyond these tendencies - which are a result of the physical constraints - is the world of system design options.</p>
<p>Both performance and availability are defined by the external guarantees the system makes. On a high level, you can think of the guarantees as the SLA (service level agreement) for the system: if I write data, how quickly can I access it elsewhere? After the data is written, what guarantees do I have of durability? If I ask the system to run a computation, how quickly will it return results? When components fail, or are taken out of operation, what impact will this have on the system?</p>
<p>There is another criterion, which is not explicitly mentioned but implied: intelligibility. How understandable are the guarantees that are made? Of course, there are no simple metrics for what is intelligible.</p>
<p>I was kind of tempted to put &quot;intelligibility&quot; under physical limitations. After all, it is a hardware limitation in people that we have a hard time understanding anything that involves <a href="http://en.wikipedia.org/wiki/Working_memory#Capacity">more moving things than we have fingers</a>. That&#39;s the difference between an error and an anomaly - an error is incorrect behavior, while an anomaly is unexpected behavior. If you were smarter, you&#39;d expect the anomalies to occur.</p>
<h2>Abstractions and models</h2>
<p>This is where abstractions and models come into play. Abstractions make things more manageable by removing real-world aspects that are not relevant to solving a problem. Models describe the key properties of a distributed system in a precise manner. I&#39;ll discuss many kinds of models in the next chapter, such as:</p>
<ul class="list">
<li>System model (asynchronous / synchronous)</li>
<li>Failure model (crash-fail, partitions, Byzantine)</li>
<li>Consistency model (strong, eventual)</li>
</ul>
<p>A good abstraction makes working with a system easier to understand, while capturing the factors that are relevant for a particular purpose.</p>
<p>There is a tension between the reality that there are many nodes and with our desire for systems that &quot;work like a single system&quot;. Often, the most familiar model (for example, implementing a shared memory abstraction on a distributed system) is too expensive.</p>
<p>A system that makes weaker guarantees has more freedom of action, and hence potentially greater performance - but it is also potentially hard to reason about. People are better at reasoning about systems that work like a single system, rather than a collection of nodes.</p>
<p>One can often gain performance by exposing more details about the internals of the system. For example, in <a href="http://en.wikipedia.org/wiki/Column-oriented_DBMS">columnar storage</a>, the user can (to some extent) reason about the locality of the key-value pairs within the system and hence make decisions that influence the performance of typical queries. Systems which hide these kinds of details are easier to understand (since they act more like single unit, with fewer details to think about), while systems that expose more real-world details may be more performant (because they correspond more closely to reality).</p>
<p>Several types of failures make writing distributed systems that act like a single system difficult. Network latency and network partitions (e.g. total network failure between some nodes) mean that a system needs to sometimes make hard choices about whether it is better to stay available but lose some crucial guarantees that cannot be enforced, or to play it safe and refuse clients when these types of failures occur.</p>
<p>The CAP theorem - which I will discuss in the next chapter - captures some of these tensions. In the end, the ideal system meets both programmer needs (clean semantics) and business needs (availability/consistency/latency).</p>
<h2>Design techniques: partition and replicate</h2>
<p>The manner in which a data set is distributed between multiple nodes is very important. In order for any computation to happen, we need to locate the data and then act on it.</p>
<p>There are two basic techniques that can be applied to a data set. It can be split over multiple nodes (partitioning) to allow for more parallel processing. It can also be copied or cached on different nodes to reduce the distance between the client and the server and for greater fault tolerance (replication).</p>
<blockquote>
<p>Divide and conquer - I mean, partition and replicate.</p>
</blockquote>
<p>The picture below illustrates the difference between these two: partitioned data (A and B below) is divided into independent sets, while replicated data (C below) is copied to multiple locations.</p>
<p class="img-container"><img src="images/part-repl.png" alt="Partition and replicate"></p>
<p>This is the one-two punch for solving any problem where distributed computing plays a role. Of course, the trick is in picking the right technique for your concrete implementation; there are many algorithms that implement replication and partitioning, each with different limitations and advantages which need to be assessed against your design objectives.</p>
<h3>Partitioning</h3>
<p>Partitioning is dividing the dataset into smaller distinct independent sets; this is used to reduce the impact of dataset growth since each partition is a subset of the data.</p>
<ul class="list">
<li>Partitioning improves performance by limiting the amount of data to be examined and by locating related data in the same partition</li>
<li>Partitioning improves availability by allowing partitions to fail independently, increasing the number of nodes that need to fail before availability is sacrificed</li>
</ul>
<p>Partitioning is also very much application-specific, so it is hard to say much about it without knowing the specifics. That&#39;s why the focus is on replication in most texts, including this one.</p>
<p>Partitioning is mostly about defining your partitions based on what you think the primary access pattern will be, and dealing with the limitations that come from having independent partitions (e.g. inefficient access across partitions, different rate of growth etc.).</p>
<h3>Replication</h3>
<p>Replication is making copies of the same data on multiple machines; this allows more servers to take part in the computation.</p>
<p>Let me inaccurately quote <a href="http://en.wikipedia.org/wiki/Homer_vs._the_Eighteenth_Amendment">Homer J. Simpson</a>:</p>
<blockquote>
<p>To replication! The cause of, and solution to all of life&#39;s problems.</p>
</blockquote>
<p>Replication - copying or reproducing something - is the primary way in which we can fight latency.</p>
<ul class="list">
<li>Replication improves performance by making additional computing power and bandwidth applicable to a new copy of the data</li>
<li>Replication improves availability by creating additional copies of the data, increasing the number of nodes that need to fail before availability is sacrificed</li>
</ul>
<p>Replication is about providing extra bandwidth, and caching where it counts. It is also about maintaining consistency in some way according to some consistency model.</p>
<p>Replication allows us to achieve scalability, performance and fault tolerance. Afraid of loss of availability or reduced performance? Replicate the data to avoid a bottleneck or single point of failure. Slow computation? Replicate the computation on multiple systems. Slow I/O? Replicate the data to a local cache to reduce latency or onto multiple machines to increase throughput.</p>
<p>Replication is also the source of many of the problems, since there are now independent copies of the data that has to be kept in sync on multiple machines - this means ensuring that the replication follows a consistency model.</p>
<p>The choice of a consistency model is crucial: a good consistency model provides clean semantics for programmers (in other words, the properties it guarantees are easy to reason about) and meets business/design goals such as high availability or strong consistency.</p>
<p>Only one consistency model for replication - strong consistency - allows you to program as-if the underlying data was not replicated. Other consistency models expose some internals of the replication are visible to the programmer. However, weaker consistency models can provide lower latency and higher availability - and are not necessarily harder to understand, just different.</p>
<hr>
<h2>Further reading</h2>
<ul class="list">
<li><a href="http://www.morganclaypool.com/doi/pdf/10.2200/s00193ed1v01y200905cac006">The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines</a> - Barroso &amp;  HÃ¶lzle, 2008</li>
<li><a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing">Fallacies of Distributed Computing</a></li>
<li><a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">Notes on Distributed Systems for Young Bloods</a> - Hodges, 2013</li>
</ul>
<div style="page-break-after: always;"></div><a name="abstractions"></a><h1>2. Up and down the level of abstraction</h1>
<p>In this chapter, we&#39;ll travel up and down the level of abstraction; look at some impossibility results (CAP and FLP) and then travel back down for the sake of performance.</p>
<p>If you&#39;ve done any programming, the idea of levels of abstraction is probably familiar to you. You&#39;ll always work at some level of abstraction, interface with a lower level layer through some API, and probably provide some higher-level API or user interface to your users. The seven-layer <a href="http://en.wikipedia.org/wiki/OSI_model">OSI model of computer networking</a> is a good example of this.</p>
<p>Distributed programming is, I&#39;d assert, in large part dealing with consequences of distribution (duh!). That is, there is a tension between the reality that there are many nodes and with our desire for systems that &quot;work like a single system&quot;. That means finding a good abstraction that balances what is possible with what is understandable and performant.</p>
<p>What do we mean when say X is more abstract than Y? First, that X does not introduce anything new or fundamentally different from Y. In fact, X may remove some aspects of Y or present them in a way that makes them more manageable.
Second, that X is in some sense easier to grasp than Y, assuming that the things that X removed from Y are not important to the matter at hand.</p>
<p>As <a href="http://oregonstate.edu/instruct/phl201/modules/Philosophers/Nietzsche/Truth_and_Lie_in_an_Extra-Moral_Sense.htm">Nietzsche</a> wrote:</p>
<blockquote>
<p>Every concept originates through our equating what is unequal. No leaf ever wholly equals another, and the concept &quot;leaf&quot; is formed through an arbitrary abstraction from these individual differences, through forgetting the distinctions; and now it gives rise to the idea that in nature there might be something besides the leaves which would be &quot;leaf&quot; - some kind of original form after which all leaves have been woven, marked, copied, colored, curled, and painted, but by unskilled hands, so that no copy turned out to be a correct, reliable, and faithful image of the original form.</p>
</blockquote>
<p>Abstractions, fundamentally, are fake. Every situation is unique, as is every node. But abstractions make the world manageable: simpler problem statements - free of reality - are much more analytically tractable and provided that we did not ignore anything essential, the solutions are widely applicable.</p>
<p>Indeed, if the things that we kept around are essential, then the results we can derive will be widely applicable. This is why impossibility results are so important: they take the simplest possible formulation of a problem, and demonstrate that it is impossible to solve within some set of constraints or assumptions.</p>
<p>All abstractions ignore something in favor of equating things that are in reality unique. The trick is to get rid of everything that is not essential. How do you know what is essential? Well, you probably won&#39;t know a priori.</p>
<p>Every time we exclude some aspect of a system from our specification of the system, we risk introducing a source of error and/or a performance issue. That&#39;s why sometimes we need to go in the other direction, and selectively introduce some aspects of real hardware and the real-world problem back. It may be sufficient to reintroduce some specific hardware characteristics (e.g. physical sequentiality) or other physical characteristics to get a system that performs well enough.</p>
<p>With this in mind, what is the least amount of reality we can keep around while still working with something that is still recognizable as a distributed system? A system model is a specification of the characteristics we consider important; having specified one, we can then take a look at some impossibility results and challenges.</p>
<h2>A system model</h2>
<p>A key property of distributed systems is distribution. More specifically, programs in a distributed system:</p>
<ul class="list">
<li>run concurrently on independent nodes ...</li>
<li>are connected by a network that may introduce nondeterminism and message loss ...</li>
<li>and have no shared memory or shared clock.</li>
</ul>
<p>There are many implications:</p>
<ul class="list">
<li>each node executes a program concurrently</li>
<li>knowledge is local: nodes have fast access only to their local state, and any information about global state is potentially out of date</li>
<li>nodes can fail and recover from failure independently</li>
<li>messages can be delayed or lost (independent of node failure; it is not easy to distinguish network failure and node failure)</li>
<li>and clocks are not synchronized across nodes (local timestamps do not correspond to the global real time order, which cannot be easily observed)</li>
</ul>
<p>A system model enumerates the many assumptions associated with a particular system design.</p>
<dl>
  <dt>System model</dt>
  <dd>a set of assumptions about the environment and facilities on which a distributed system is implemented</dd>
</dl>

<p>System models vary in their assumptions about the environment and facilities. These assumptions include:</p>
<ul class="list">
<li>what capabilities the nodes have and how they may fail</li>
<li>how communication links operate and how they may fail and</li>
<li>properties of the overall system, such as assumptions about time and order</li>
</ul>
<p>A robust system model is one that makes the weakest assumptions: any algorithm written for such a system is very tolerant of different environments, since it makes very few and very weak assumptions.</p>
<p>On the other hand, we can create a system model that is easy to reason about by making strong assumptions. For example, assuming that nodes do not fail means that our algorithm does not need to handle node failures. However, such a system model is unrealistic and hence hard to apply into practice.</p>
<p>Let&#39;s look at the properties of nodes, links and time and order in more detail.</p>
<h3>Nodes in our system model</h3>
<p>Nodes serve as hosts for computation and storage. They have:</p>
<ul class="list">
<li>the ability to execute a program</li>
<li>the ability to store data into volatile memory (which can be lost upon failure) and into stable state (which can be read after a failure)</li>
<li>a clock (which may or may not be assumed to be accurate)</li>
</ul>
<p>Nodes execute deterministic algorithms: the local computation, the local state after the computation, and the messages sent are determined uniquely by the message received and local state when the message was received.</p>
<p>There are many possible failure models which describe the ways in which nodes can fail. In practice, most systems assume a crash-recovery failure model: that is, nodes can only fail by crashing, and can (possibly) recover after crashing at some later point.</p>
<p>Another alternative is to assume that nodes can fail by misbehaving in any arbitrary way. This is known as <a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance">Byzantine fault tolerance</a>. Byzantine faults are rarely handled in real world commercial systems, because algorithms resilient to arbitrary faults are more expensive to run and more complex to implement. I will not discuss them here.</p>
<h3>Communication links in our system model</h3>
<p>Communication links connect individual nodes to each other, and allow messages to be sent in either direction. Many books which discuss distributed algorithms assume is that there are individual links between each pair of nodes, that the links provide FIFO (first in, first out) order for messages, that they can only deliver messages that were sent, and that sent messages can be lost.</p>
<p>Some algorithms assume that the network is reliable: that messages are never lost and never delayed indefinitely. This may be a reasonable assumption for some real-world settings, but in general it is preferable to consider the network to be unreliable and subject to message loss and delays.</p>
<p>A network partition occurs when the network fails while the nodes themselves remain operational. When this occurs, messages may be lost or delayed until the network partition is repaired. Partitioned nodes may be accessible by some clients, and so must be treated differently from crashed nodes. The diagram below illustrates a node failure vs. a network partition:</p>
<p class="img-container"><img src="images/system-of-2.png" alt="replication" style="max-height: 100px;"></p>
<p>It is rare to make further assumptions about communication links. We could assume that links only work in one direction, or we could introduce different communication costs (e.g. latency due to physical distance) for different links. However, these are rarely concerns in commercial environments except for long-distance links (WAN latency) and so I will not discuss them here; a more detailed model of costs and topology allows for better optimization at the cost of complexity.</p>
<h3>Timing / ordering assumptions</h3>
<p>One of the consequences of physical distribution is that each node experiences the world in a unique manner. This is inescapable, because information can only travel at the speed of light. If nodes are at different distances from each other, then any messages sent from one node to the others will arrive at a different time and potentially in a different order at the other nodes.</p>
<p>Timing assumptions are a convenient shorthand for capturing assumptions about the extent to which we take this reality into account. The two main alternatives are:</p>
<dl>
  <dt>Synchronous system model</dt>
  <dd>Processes execute in lock-step; there is a known upper bound on message transmission delay; each process has an accurate clock</dd>
  <dt>Asynchronous system model</dt>
  <dd>No timing assumptions - e.g. processes execute at independent rates; there is no bound on message transmission delay; useful clocks do not exist</dd>
</dl>

<p>The synchronous system model imposes many constraints on time and order. It essentially assumes that the nodes have the same experience: that messages that are sent are always received within a particular maximum transmission delay, and that processes execute in lock-step. This is convenient, because it allows you as the system designer to make assumptions about time and order, while the asynchronous system model doesn&#39;t.</p>
<p>Asynchronicity is a non-assumption: it just assumes that you can&#39;t rely on timing (or a &quot;time sensor&quot;).</p>
<p>It is easier to solve problems in the synchronous system model, because assumptions about execution speeds, maximum message transmission delays and clock accuracy all help in solving problems since you can make inferences based on those assumptions and rule out inconvenient failure scenarios by assuming they never occur.</p>
<p>Of course, assuming the synchronous system model is not particularly realistic. Real-world networks are subject to failures and there are no hard bounds on message delay. Real world systems are at best partially synchronous: they may occasionally work correctly and provide some upper bounds, but there will be times where messages are delayed indefinitely and clocks are out of sync. I won&#39;t really discuss algorithms for synchronous systems here, but you will probably run into them in many other introductory books because they are analytically easier (but unrealistic).</p>
<h3>The consensus problem</h3>
<p>During the rest of this text, we&#39;ll vary the parameters of the system model. Next, we&#39;ll look at how varying two system properties:</p>
<ul class="list">
<li>whether or not network partitions are included in the failure model, and</li>
<li>synchronous vs. asynchronous timing assumptions</li>
</ul>
<p>influence the system design choices by discussing two impossibility results (FLP and CAP).</p>
<p>Of course, in order to have a discussion, we also need to introduce a problem to solve. The problem I&#39;m going to discuss is the <a href="http://en.wikipedia.org/wiki/Consensus_%28computer_science%29">consensus problem</a>.</p>
<p>Several computers (or nodes) achieve consensus if they all agree on some value. More formally:</p>
<ol class="list">
<li>Agreement: Every correct process must agree on the same value.</li>
<li>Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process.</li>
<li>Termination: All processes eventually reach a decision.</li>
<li>Validity: If all correct processes propose the same value V, then all correct processes decide V.</li>
</ol>
<p>The consensus problem is at the core of many commercial distributed systems. After all, we want the reliability and performance of a distributed system without having to deal with the consequences of distribution (e.g. disagreements / divergence between nodes), and solving the consensus problem makes it possible to solve several related, more advanced problems such as atomic broadcast and atomic commit.</p>
<h3>Two impossibility results</h3>
<p>The first impossibility result, known as the FLP impossibility result, is an impossibility result that is particularly relevant to people who design distributed algorithms. The second - the CAP theorem - is a related result that is more relevant to practitioners; people who need to choose between different system designs but who are not directly concerned with the design of algorithms.</p>
<h2>The FLP impossibility result</h2>
<p>I will only briefly summarize the <a href="http://en.wikipedia.org/wiki/Consensus_%28computer_science%29#Solvability_results_for_some_agreement_problems">FLP impossibility result</a>, though it is considered to be <a href="http://en.wikipedia.org/wiki/Dijkstra_Prize">more important</a> in academic circles. The FLP impossibility result (named after the authors, Fischer, Lynch and Patterson) examines the consensus problem under the asynchronous system model (technically, the agreement problem, which is a very weak form of the consensus problem). It is assumed that nodes can only fail by crashing; that the network is reliable, and that the typical timing assumptions of the asynchronous system model hold: e.g. there are no bounds on message delay.</p>
<p>Under these assumptions, the FLP result states that &quot;there does not exist a (deterministic) algorithm for the consensus problem in an asynchronous system subject to failures, even if messages can never be lost, at most one process may fail, and it can only fail by crashing (stopping executing)&quot;.</p>
<p>This result means that there is no way to solve the consensus problem under a very minimal system model in a way that cannot be delayed forever.  The argument is that if such an algorithm existed, then one could devise an execution of that algorithm in which it would remain undecided (&quot;bivalent&quot;) for an arbitrary amount of time by delaying message delivery - which is allowed in the asynchronous system model. Thus, such an algorithm cannot exist.</p>
<p>This impossibility result is important because it highlights that assuming the asynchronous system model leads to a tradeoff: algorithms that solve the consensus problem must either give up safety or liveness when the guarantees regarding bounds on message delivery do not hold.</p>
<p>This insight is particularly relevant to people who design algorithms, because it imposes a hard constraint on the problems that we know are solvable in the asynchronous system model. The CAP theorem is a related theorem that is more relevant to practitioners: it makes slightly different assumptions (network failures rather than node failures), and has more clear implications for practitioners choosing between system designs.</p>
<h2>The CAP theorem</h2>
<p>The CAP theorem was initially a conjecture made by computer scientist Eric Brewer. It&#39;s a popular and fairly useful way to think about tradeoffs in the guarantees that a system design makes. It even has a <a href="https://www.google.com/search?q=Brewer&#39;s+conjecture+and+the+feasibility+of+consistent%2C+available%2C+partition-tolerant+web+services">formal proof</a> by <a href="http://www.comp.nus.edu.sg/~gilbert/biblio.html">Gilbert</a> and <a href="http://en.wikipedia.org/wiki/Nancy_Lynch">Lynch</a> and no, <a href="http://nathanmarz.com/">Nathan Marz</a> didn&#39;t debunk it, in spite of what <a href="http://news.ycombinator.com/">a particular discussion site</a> thinks.</p>
<p>The theorem states that of these three properties:</p>
<ul class="list">
<li>Consistency: all nodes see the same data at the same time.</li>
<li>Availability: node failures do not prevent survivors from continuing to operate.</li>
<li>Partition tolerance: the system continues to operate despite message loss due to network and/or node failure</li>
</ul>
<p>only two can be satisfied simultaneously. We can even draw this as a pretty diagram, picking two properties out of three gives us three types of systems that correspond to different intersections:</p>
<p class="img-container"><img src="images/CAP.png" alt="CAP theorem"></p>
<p>Note that the theorem states that the middle piece (having all three properties) is not achievable. Then we get three different system types:</p>
<ul class="list">
<li>CA (consistency + availability). Examples include full strict quorum protocols, such as two-phase commit.</li>
<li>CP (consistency + partition tolerance). Examples include majority quorum protocols in which minority partitions are unavailable such as Paxos.</li>
<li>AP (availability + partition tolerance). Examples include protocols using conflict resolution, such as Dynamo.</li>
</ul>
<p>The CA and CP system designs both offer the same consistency model: strong consistency. The only difference is that a CA system cannot tolerate any node failures; a CP system can tolerate up to <code>f</code> faults given <code>2f+1</code> nodes in a non-Byzantine failure model (in other words, it can tolerate the failure of a minority <code>f</code> of the nodes as long as majority <code>f+1</code> stays up). The reason is simple:</p>
<ul class="list">
<li>A CA system does not distinguish between node failures and network failures, and hence must stop accepting writes everywhere to avoid introducing divergence (multiple copies). It cannot tell whether a remote node is down, or whether just the network connection is down: so the only safe thing is to stop accepting writes.</li>
<li>A CP system prevents divergence (e.g. maintains single-copy consistency) by forcing asymmetric behavior on the two sides of the partition. It only keeps the majority partition around, and requires the minority partition to become unavailable (e.g. stop accepting writes), which retains a degree of availability (the majority partition) and still ensures single-copy consistency.</li>
</ul>
<p>I&#39;ll discuss this in more detail in the chapter on replication when I discuss Paxos. The important thing is that CP systems incorporate network partitions into their failure model and distinguish between a majority partition and a minority partition using an algorithm like Paxos, Raft or viewstamped replication. CA systems are not partition-aware, and are historically more common: they often use the two-phase commit algorithm and are common in traditional distributed relational databases.</p>
<p>Assuming that a partition occurs, the theorem reduces to a binary choice between availability and consistency.</p>
<p class="img-container"><img src="images/CAP_choice.png" alt="Based on http://blog.mikiobraun.de/2013/03/misconceptions-about-cap-theorem.html"></p>
<p>I think there are three conclusions that should be drawn from the CAP theorem:</p>
<p>First, that <em>many system designs used in early distributed relational database systems did not take into account partition tolerance</em> (e.g. they were CA designs). Partition tolerance is an important property for modern systems, since network partitions become much more likely if the system is geographically distributed (as many large systems are).</p>
<p>Second, that <em>there is a tension between strong consistency and high availability during network partitions</em>. The CAP theorem is an illustration of the tradeoffs that occur between strong guarantees and distributed computation.</p>
<p>In some sense, it is quite crazy to promise that a distributed system consisting of independent nodes connected by an unpredictable network &quot;behaves in a way that is indistinguishable from a non-distributed system&quot;.</p>
<p class="img-container"><img src="images/news_120.jpg" alt="From the Simpsons episode Trash of the Titans"></p>
<p>Strong consistency guarantees require us to give up availability during a partition. This is because one cannot prevent divergence between two replicas that cannot communicate with each other while continuing to accept writes on both sides of the partition.</p>
<p>How can we work around this? By strengthening the assumptions (assume no partitions) or by weakening the guarantees. Consistency can be traded off against availability (and the related capabilities of offline accessibility and low latency). If &quot;consistency&quot; is defined as something less than &quot;all nodes see the same data at the same time&quot; then we can have both availability and some (weaker) consistency guarantee.</p>
<p>Third, that <em>there is a tension between strong consistency and performance in normal operation</em>.</p>
<p>Strong consistency / single-copy consistency requires that nodes communicate and agree on every operation. This results in high latency during normal operation.</p>
<p>If you can live with a consistency model other than the classic one; a consistency model that allows replicas to lag or to diverge, then you can reduce latency during normal operation and maintain availability in the presence of partitions.</p>
<p>When fewer messages and fewer nodes are involved, an operation can complete faster. But the only way to accomplish that is to relax the guarantees: let some of the nodes be contacted less frequently, which means that nodes can contain old data.</p>
<p>This also makes it possible for anomalies to occur. You are no longer guaranteed to get the most recent value. Depending on what kinds of guarantees are made, you might read a value that is older than expected, or even lose some updates.</p>
<p>Fourth - and somewhat indirectly - that <em>if we do not want to give up availability during a network partition, then we need to explore whether consistency models other than strong consistency are workable for our purposes</em>.</p>
<p>For example, even if user data is georeplicated to multiple datacenters, and the link between those two datacenters is temporarily out of order, in many cases we&#39;ll still want to allow the user to use the website / service. This means reconciling two divergent sets of data later on, which is both a technical challenge and a business risk. But often both the technical challenge and the business risk are manageable, and so it is preferable to provide high availability.</p>
<p>Consistency and availability are not really binary choices, unless you limit yourself to strong consistency. But strong consistency is just one consistency model: the one where you, by necessity, need to give up availability in order to prevent more than a single copy of the data from being active. As <a href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">Brewer himself points out</a>, the &quot;2 out of 3&quot; interpretation is misleading.</p>
<p>If you take away just one idea from this discussion, let it be this: &quot;consistency&quot; is not a singular, unambiguous property. Remember:</p>
<blockquote>
  <p>
   <a href="http://en.wikipedia.org/wiki/ACID">ACID</a> consistency != <br>
   <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP</a> consistency != <br>
   <a href="http://en.wikipedia.org/wiki/Oatmeal">Oatmeal</a> consistency
  </p>
</blockquote>

<p>Instead, a consistency model is a guarantee - any guarantee - that a data store gives to programs that use it.</p>
<dl>
  <dt>Consistency model</dt>
  <dd>a contract between programmer and system, wherein the system guarantees that if the programmer follows some specific rules, the results of operations on the data store will be predictable</dd>
</dl>

<p>The &quot;C&quot; in CAP is &quot;strong consistency&quot;, but &quot;consistency&quot; is not a synonym for &quot;strong consistency&quot;.</p>
<p>Let&#39;s take a look at some alternative consistency models.</p>
<h2>Strong consistency vs. other consistency models</h2>
<p>Consistency models can be categorized into two types: strong and weak consistency models:</p>
<ul class="list">
<li>Strong consistency models (capable of maintaining a single copy)<ul class="list">
<li>Linearizable consistency</li>
<li>Sequential consistency</li>
</ul>
</li>
<li>Weak consistency models (not strong)<ul class="list">
<li>Client-centric consistency models</li>
<li>Causal consistency: strongest model available</li>
<li>Eventual consistency models</li>
</ul>
</li>
</ul>
<p>Strong consistency models guarantee that the apparent order and visibility of updates is equivalent to a non-replicated system. Weak consistency models, on the other hand, do not make such guarantees.</p>
<p>Note that this is by no means an exhaustive list. Again, consistency models are just arbitrary contracts between the programmer and system, so they can be almost anything.</p>
<h3>Strong consistency models</h3>
<p>Strong consistency models can further be divided into two similar, but slightly different consistency models:</p>
<ul class="list">
<li><em>Linearizable consistency</em>: Under linearizable consistency, all operations <strong>appear</strong> to have executed atomically in an order that is consistent with the global real-time ordering of operations. (Herlihy &amp; Wing, 1991)</li>
<li><em>Sequential consistency</em>: Under sequential consistency, all operations <strong>appear</strong> to have executed atomically in some order that is consistent with the order seen at individual nodes and that is equal at all nodes. (Lamport, 1979)</li>
</ul>
<p>The key difference is that linearizable consistency requires that the order in which operations take effect is equal to the actual real-time ordering of operations. Sequential consistency allows for operations to be reordered as long as the order observed on each node remains consistent. The only way someone can distinguish between the two is if they can observe all the inputs and timings going into the system; from the perspective of a client interacting with a node, the two are equivalent.</p>
<p>The difference seems immaterial, but it is worth noting that sequential consistency does not compose.</p>
<p>Strong consistency models allow you as a programmer to replace a single server with a cluster of distributed nodes and not run into any problems.</p>
<p>All the other consistency models have anomalies (compared to a system that guarantees strong consistency), because they behave in a way that is distinguishable from a non-replicated system. But often these anomalies are acceptable, either because we don&#39;t care about occasional issues or because we&#39;ve written code that deals with inconsistencies after they have occurred in some way.</p>
<p>Note that there really aren&#39;t any universal typologies for weak consistency models, because &quot;not a strong consistency model&quot; (e.g. &quot;is distinguishable from a non-replicated system in some way&quot;) can be almost anything.</p>
<h3>Client-centric consistency models</h3>
<p><em>Client-centric consistency models</em> are consistency models are consistency models which involve the notion of a client or session in some way. For example, a client-centric consistency model might guarantee that a client will never see older versions of a data item. This is often implemented by building additional caching into the client library, so that if a client moves to a replica node that contains old data, then the client library returns its cached value rather than the old value from the replica.</p>
<p>Clients may still see older versions of the data, if the replica node they are on does not contain the latest version, but they will never see anomalies where an older version of a value resurfaces (e.g. because they connected to a different replica). Note that there are many kinds of consistency models that are client-centric.</p>
<h3>Eventual consistency</h3>
<p>The <em>eventual consistency</em> model says that if you stop changing values, then after some undefined amount of time all replicas will agree on the same value. It is implied that before that time results between replicas are inconsistent in some undefined manner. Since it is <a href="http://www.bailis.org/blog/safety-and-liveness-eventual-consistency-is-not-safe/">trivially satisfiable</a> (liveness property only), it is useless without supplemental information.</p>
<p>Saying something is merely eventually consistent is like saying &quot;people are eventually dead&quot;. It&#39;s a very weak constraint, and we&#39;d probably want to have at least some more specific characterization of two things:</p>
<p>First, how long is &quot;eventually&quot;? It would be useful to have a strict lower bound, or at least some idea of how long it typically takes for the system to converge to the same value.</p>
<p>Second, how do the replicas agree on a value? A system that always returns &quot;42&quot; is eventually consistent: all replicas agree on the same value. It just doesn&#39;t converge to a useful value since it just keeps returning the same fixed value. Instead, we&#39;d like to have a better idea of the method. For example, one way to decide is to have the value with the largest timestamp always win.</p>
<p>So when vendors say &quot;eventual consistency&quot;, what they mean is some more precise term, such as &quot;eventually last-writer-wins, and read-the-latest-observed-value in the meantime&quot; consistency. The &quot;how?&quot; matters, because a bad method can lead to writes being lost - for example, if the clock on one node is set incorrectly and timestamps are used.</p>
<p>I will look into these two questions in more detail in the chapter on replication methods for weak consistency models.</p>
<hr>
<h2>Further reading</h2>
<ul class="list">
<li><a href="http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf">Brewer&#39;s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a> - Gilbert &amp; Lynch, 2002</li>
<li><a href="http://scholar.google.com/scholar?q=Impossibility+of+distributed+consensus+with+one+faulty+process">Impossibility of distributed consensus with one faulty process</a> - Fischer, Lynch and Patterson, 1985</li>
<li><a href="http://scholar.google.com/scholar?q=Perspectives+on+the+CAP+Theorem">Perspectives on the CAP Theorem</a> - Gilbert &amp; Lynch, 2012</li>
<li><a href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the &quot;Rules&quot; Have Changed</a> - Brewer, 2012</li>
<li><a href="http://scholar.google.com/scholar?q=Uniform+consensus+is+harder+than+consensus">Uniform consensus is harder than consensus</a> - Charron-Bost &amp; Schiper, 2000</li>
<li><a href="http://pages.cs.wisc.edu/~remzi/Classes/739/Papers/Bart/ConsistencyAndBaseballReport.pdf">Replicated Data Consistency Explained Through Baseball</a> - Terry, 2011</li>
<li><a href="http://scholar.google.com/scholar?q=Life+Beyond+Distributed+Transactions%3A+an+Apostate%27s+Opinion">Life Beyond Distributed Transactions: an Apostate&#39;s Opinion</a> - Helland, 2007</li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953140">If you have too much data, then &#39;good enough&#39; is good enough</a> - Helland, 2011</li>
<li><a href="http://scholar.google.com/scholar?q=Building+on+Quicksand">Building on Quicksand</a> - Helland &amp; Campbell, 2009</li>
</ul>
<div style="page-break-after: always;"></div><a name="time"></a><h1>3. Time and order</h1>
<p>What is order and why is it important?</p>
<p>What do you mean &quot;what is order&quot;?</p>
<p>I mean, why are we so obsessed with order in the first place? Why do we care whether A happened before B? Why don&#39;t we care about some other property, like &quot;color&quot;?</p>
<p>Well, my crazy friend, let&#39;s go back to the definition of distributed systems to answer that.</p>
<p>As you may remember, I described distributed programming as the art of solving the same problem that you can solve on a single computer using multiple computers.</p>
<p>This is, in fact, at the core of the obsession with order. Any system that can only do one thing at a time will create a total order of operations. Like people passing through a single door, every operation will have a well-defined predecessor and successor. That&#39;s basically the programming model that we&#39;ve worked very hard to preserve.</p>
<p>The traditional model is: a single program, one process, one memory space running on one CPU. The operating system abstracts away the fact that there might be multiple CPUs and multiple programs, and that the memory on the computer is actually shared among many programs. I&#39;m not saying that threaded programming and event-oriented programming don&#39;t exist; it&#39;s just that they are special abstractions on top of the &quot;one/one/one&quot; model. Programs are written to be executed in an ordered fashion: you start from the top, and then go down towards the bottom.</p>
<p>Order as a property has received so much attention because the easiest way to define &quot;correctness&quot; is to say &quot;it works like it would on a single machine&quot;. And that usually means that a) we run the same operations and b) that we run them in the same order - even if there are multiple machines.</p>
<p>The nice thing about distributed systems that preserve order (as defined for a single system) is that they are generic. You don&#39;t need to care about what the operations are, because they will be executed exactly like on a single machine. This is great because you know that you can use the same system no matter what the operations are.</p>
<p>In reality, a distributed program runs on multiple nodes; with multiple CPUs and multiple streams of operations coming in. You can still assign a total order, but it requires either accurate clocks or some form of communication. You could timestamp each operation using a completely accurate clock then use that to figure out the total order. Or you might have some kind of communication system that makes it possible to assign sequential numbers as in a total order.</p>
<h2>Total and partial order</h2>
<p>The natural state in a distributed system is <a href="http://en.wikipedia.org/wiki/Partially_ordered_set">partial order</a>. Neither the network nor independent nodes make any guarantees about relative order; but at each node, you can observe a local order.</p>
<p>A <a href="http://en.wikipedia.org/wiki/Total_order">total order</a> is a binary relation that defines an order for every element in some set.</p>
<p>Two distinct elements are <strong>comparable</strong> when one of them is greater than the other. In a partially ordered set, some pairs of elements are not comparable and hence a partial order doesn&#39;t specify the exact order of every item.</p>
<p>Both total order and partial order are <a href="http://en.wikipedia.org/wiki/Transitive_relation">transitive</a> and <a href="http://en.wikipedia.org/wiki/Antisymmetric_relation">antisymmetric</a>. The following statements hold in both a total order and a partial order for all a, b and c in X:</p>
<pre>If a â¤ b and b â¤ a then a = b (antisymmetry);
If a â¤ b and b â¤ c then a â¤ c (transitivity);</pre>
<p>However, a total order is <a href="http://en.wikipedia.org/wiki/Total_relation">total</a>:</p>
<pre>a â¤ b or b â¤ a (totality) for all a, b in X</pre>
<p>while a partial order is only <a href="http://en.wikipedia.org/wiki/Reflexive_relation">reflexive</a>:</p>
<pre>a â¤ a (reflexivity) for all a in X</pre>
<p>Note that totality implies reflexivity; so a partial order is a weaker variant of total order.
For some elements in a partial order, the totality property does not hold - in other words, some of the elements are not comparable.</p>
<p>Git branches are an example of a partial order. As you probably know, the git revision control system allows you to create multiple branches from a single base branch - e.g. from a master branch. Each branch represents a history of source code changes derived based on a common ancestor:</p>
<pre>[ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]
[ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]
                  \  [ master (1,0,0) ]  /</pre>
<p>The branches A and B were derived from a common ancestor, but there is no definite order between them: they represent different histories and cannot be reduced to a single linear history without additional work (merging). You could, of course, put all the commits in some arbitrary order (say, sorting them first by ancestry and then breaking ties by sorting A before B or B before A) - but that would lose information by forcing a total order where none existed.</p>
<p>In a system consisting of one node, a total order emerges by necessity: instructions are executed and messages are processed in a specific, observable order in a single program. We&#39;ve come to rely on this total order - it makes executions of programs predictable. This order can be maintained on a distributed system, but at a cost: communication is expensive, and time synchronization is difficult and fragile.</p>
<h1>What is time?</h1>
<p>Time is a source of order - it allows us to define the order of operations - which coincidentally also has an interpretation that people can understand (a second, a minute, a day and so on).</p>
<p>In some sense, time is just like any other integer counter. It just happens to be important enough that most computers have a dedicated time sensor, also known as a clock. It&#39;s so important that we&#39;ve figured out how to synthesize an approximation of the same counter using some imperfect physical system (from wax candles to cesium atoms). By &quot;synthesize&quot;, I mean that we can approximate the value of the integer counter in physically distant places via some physical property without communicating it directly.</p>
<p>Timestamps really are a shorthand value for representing the state of the world from the start of the universe to the current moment - if something occurred at a particular timestamp, then it was potentially influenced by everything that happened before it. This idea can be generalized into a causal clock that explicitly tracks causes (dependencies) rather than simply assuming that everything that preceded a timestamp was relevant. Of course, the usual assumption is that we should only worry about the state of the specific system rather than the whole world.</p>
<p>Assuming that time progresses at the same rate everywhere - and that is a big assumption which I&#39;ll return to in a moment - time and timestamps have several useful interpretations when used in a program. The three interpretations are:</p>
<ul class="list">
<li>Order</li>
<li>Duration</li>
<li>Interpretation</li>
</ul>
<p><em>Order</em>. When I say that time is a source of order, what I mean is that:</p>
<ul class="list">
<li>we can attach timestamps to unordered events to order them</li>
<li>we can use timestamps to enforce a specific ordering of operations or the delivery of messages (for example, by delaying an operation if it arrives out of order)</li>
<li>we can use the value of a timestamp to determine whether something happened chronologically before something else</li>
</ul>
<p><em>Interpretation</em> - time as a universally comparable value. The absolute value of a timestamp can be interpreted as a date, which is useful for people. Given a timestamp of when a downtime started from a log file, you can tell that it was last Saturday, when there was a <a href="https://twitter.com/AWSFail/statuses/218915147060752384">thunderstorm</a>.</p>
<p><em>Duration</em> - durations measured in time have some relation to the real world. Algorithms generally don&#39;t care about the absolute value of a clock or its interpretation as a date, but they might use durations to make some judgment calls. In particular, the amount of time spent waiting can provide clues about whether a system is partitioned or merely experiencing high latency.</p>
<p>By their nature, the components of distributed systems do not behave in a predictable manner. They do not guarantee any specific order, rate of advance, or lack of delay. Each node does have some local order - as execution is (roughly) sequential - but these local orders are independent of each other.</p>
<p>Imposing (or assuming) order is one way to reduce the space of possible executions and possible occurrences. Humans have a hard time reasoning about things when things can happen in any order - there just are too many permutations to consider.</p>
<h2>Does time progress at the same rate everywhere?</h2>
<p>We all have an intuitive concept of time based on our own experience as individuals. Unfortunately, that intuitive notion of time makes it easier to picture total order rather than partial order. It&#39;s easier to picture a sequence in which things happen one after another, rather than concurrently. It is easier to reason about a single order of messages than to reason about messages arriving in different orders and with different delays.</p>
<p>However, when implementing distributing systems we want to avoid making strong assumptions about time and order, because the stronger the assumptions, the more fragile a system is to issues with the &quot;time sensor&quot; - or the onboard clock. Furthermore, imposing an order carries a cost. The more temporal nondeterminism that we can tolerate, the more we can take advantage of distributed computation.</p>
<p>There are three common answers to the question &quot;does time progress at the same rate everywhere?&quot;. These are:</p>
<ul class="list">
<li>&quot;Global clock&quot;: yes</li>
<li>&quot;Local clock&quot;: no, but</li>
<li>&quot;No clock&quot;: no!</li>
</ul>
<p>These correspond roughly to the three timing assumptions that I mentioned in the second chapter: the synchronous system model has a global clock, the partially synchronous model has a local clock, and in the asynchronous system model one cannot use clocks at all. Let&#39;s look at these in more detail.</p>
<h3>Time with a &quot;global-clock&quot; assumption</h3>
<p>The global clock assumption is that there is a global clock of perfect accuracy, and that everyone has access to that clock. This is the way we tend to think about time, because in human interactions small differences in time don&#39;t really matter.</p>
<p class="img-container"><img src="images/global-clock.png" alt="Global clock"></p>
<p>The global clock is basically a source of total order (exact order of every operation on all nodes even if those nodes have never communicated).</p>
<p>However, this is an idealized view of the world: in reality, clock synchronization is only possible to a limited degree of accuracy. This is limited by the lack of accuracy of clocks in commodity computers, by latency if a clock synchronization protocol such as <a href="http://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a> is used and fundamentally by <a href="http://en.wikipedia.org/wiki/Time_dilation">the nature of spacetime</a>.</p>
<p>Assuming that clocks on distributed nodes are perfectly synchronized means assuming that clocks start at the same value and never drift apart. It&#39;s a nice assumption because you can use timestamps freely to determine a global total order - bound by clock drift rather than latency - but this is a <a href="http://queue.acm.org/detail.cfm?id=1773943">nontrivial</a> operational challenge and a potential source of anomalies. There are many different scenarios where a simple failure - such as a user accidentally changing the local time on a machine, or an out-of-date machine joining a cluster, or synchronized clocks drifting at slightly different rates and so on that can cause hard-to-trace anomalies.</p>
<p>Nevertheless, there are some real-world systems that make this assumption. Facebook&#39;s <a href="http://en.wikipedia.org/wiki/Apache_Cassandra">Cassandra</a> is an example of a system that assumes clocks are synchronized. It uses timestamps to resolve conflicts between writes - the write with the newer timestamp wins. This means that if clocks drift, new data may be ignored or overwritten by old data; again, this is an operational challenge (and from what I&#39;ve heard, one that people are acutely aware of). Another interesting example is Google&#39;s <a href="http://research.google.com/archive/spanner.html">Spanner</a>: the paper describes their TrueTime API, which synchronizes time but also estimates worst-case clock drift.</p>
<h3>Time with a &quot;Local-clock&quot; assumption</h3>
<p>The second, and perhaps more plausible assumption is that each machine has its own clock, but there is no global clock. It means that you cannot use the local clock in order to determine whether a remote timestamp occurred before or after a local timestamp; in other words, you cannot meaningfully compare timestamps from two different machines.</p>
<p class="img-container"><img src="images/local-clock.png" alt="Local clock"></p>
<p>The local clock assumption corresponds more closely to the real world. It assigns a partial order: events on each system are ordered but events cannot be ordered across systems by only using a clock.</p>
<p>However, you can use timestamps to order events on a single machine; and you can use timeouts on a single machine as long as you are careful not to allow the clock to jump around. Of course, on a machine controlled by an end-user this is probably assuming too much: for example, a user might accidentally change their date to a different value while looking up a date using the operating system&#39;s date control.</p>
<h3>Time with a &quot;No-clock&quot; assumption</h3>
<p>Finally, there is the notion of logical time. Here, we don&#39;t use clocks at all and instead track causality in some other way. Remember, a timestamp is simply a shorthand for the state of the world up to that point - so we can use counters and communication to determine whether something happened before, after or concurrently with something else.</p>
<p>This way, we can determine the order of events between different machines, but cannot say anything about intervals and cannot use timeouts (since we assume that there is no &quot;time sensor&quot;). This is a partial order: events can be ordered on a single system using a counter and no communication, but ordering events across systems requires a message exchange.</p>
<p>One of the most cited papers in distributed systems is Lamport&#39;s paper on <a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">time, clocks and the ordering of events</a>. Vector clocks, a generalization of that concept (which I will cover in more detail), are a way to track causality without using clocks. Cassandra&#39;s cousins Riak (Basho) and Voldemort (Linkedin) use vector clocks rather than assuming that nodes have access to a global clock of perfect accuracy. This allows those systems to avoid the clock accuracy issues mentioned earlier.</p>
<p>When clocks are not used, the maximum precision at which events can be ordered across distant machines is bound by communication latency.</p>
<h2>How is time used in a distributed system?</h2>
<p>What is the benefit of time?</p>
<ol class="list">
<li>Time can define order across a system (without communication)</li>
<li>Time can define boundary conditions for algorithms</li>
</ol>
<p>The order of events is important in distributed systems, because many properties of distributed systems are defined in terms of the order of operations/events:</p>
<ul class="list">
<li>where correctness depends on (agreement on) correct event ordering, for example serializability in a distributed database</li>
<li>order can be used as a tie breaker when resource contention occurs, for example if there are two orders for a widget, fulfill the first and cancel the second one</li>
</ul>
<p>A global clock would allow operations on two different machines to be ordered without the two machines communicating directly. Without a global clock, we need to communicate in order to determine order.</p>
<p>Time can also be used to define boundary conditions for algorithms - specifically, to distinguish between &quot;high latency&quot; and &quot;server or network link is down&quot;. This is a very important use case; in most real-world systems timeouts are used to determine whether a remote machine has failed, or whether it is simply experiencing high network latency. Algorithms that make this determination are called failure detectors; and I will discuss them fairly soon.</p>
<h2>Vector clocks (time for causal order)</h2>
<p>Earlier, we discussed the different assumptions about the rate of progress of time across a distributed system. Assuming that we cannot achieve accurate clock synchronization - or starting with the goal that our system should not be sensitive to issues with time synchronization, how can we order things?</p>
<p>Lamport clocks and vector clocks are replacements for physical clocks which rely on counters and communication to determine the order of events across a distributed system. These clocks provide a counter that is comparable across different nodes.</p>
<p><em>A Lamport clock</em> is simple. Each process maintains a counter using the following rules:</p>
<ul class="list">
<li>Whenever a process does work, increment the counter</li>
<li>Whenever a process sends a message, include the counter</li>
<li>When a message is received, set the counter to <code>max(local_counter, received_counter) + 1</code></li>
</ul>
<p>Expressed as code:</p>
<pre>function LamportClock() {
  this.value = 1;
}

LamportClock.prototype.get = function() {
  return this.value;
}

LamportClock.prototype.increment = function() {
  this.value++;
}

LamportClock.prototype.merge = function(other) {
  this.value = Math.max(this.value, other.value) + 1;
}</pre>
<p>A <a href="http://en.wikipedia.org/wiki/Lamport_timestamps">Lamport clock</a> allows counters to be compared across systems, with a caveat: Lamport clocks define a partial order. If <code>timestamp(a) &lt; timestamp(b)</code>:</p>
<ul class="list">
<li><code>a</code> may have happened before <code>b</code> or</li>
<li><code>a</code> may be incomparable with <code>b</code></li>
</ul>
<p>This is known as clock consistency condition: if one event comes before another, then that event&#39;s logical clock comes before the others. If <code>a</code> and <code>b</code> are from the same causal history, e.g. either both timestamp values were produced on the same process; or <code>b</code> is a response to the message sent in <code>a</code> then we know that <code>a</code> happened before <code>b</code>.</p>
<p>Intuitively, this is because a Lamport clock can only carry information about one timeline / history; hence, comparing Lamport timestamps from systems that never communicate with each other may cause concurrent events to appear to be ordered when they are not.</p>
<p>Imagine a system that after an initial period divides into two independent subsystems which never communicate with each other.</p>
<p>For all events in each independent system, if a happened before b, then <code>ts(a) &lt; ts(b)</code>; but if you take two events from the different independent systems (e.g. events that are not causally related) then you cannot say anything meaningful about their relative order.  While each part of the system has assigned timestamps to events, those timestamps have no relation to each other. Two events may appear to be ordered even though they are unrelated.</p>
<p>However - and this is still a useful property - from the perspective of a single machine, any message sent with <code>ts(a)</code> will receive a response with <code>ts(b)</code> which is <code>&gt; ts(a)</code>.</p>
<p><em>A vector clock</em> is an extension of Lamport clock, which maintains an array <code>[ t1, t2, ... ]</code> of N logical clocks - one per each node. Rather than incrementing a common counter, each node increment&#39;s its own logical clock in the vector by one on each internal event. Hence the update rules are:</p>
<ul class="list">
<li>Whenever a process does work, increment the logical clock value of the node in the vector</li>
<li>Whenever a process sends a message, include the full vector of logical clocks</li>
<li>When a message is received:<ul class="list">
<li>update each element in the vector to be <code>max(local, received)</code></li>
<li>increment the logical clock value representing the current node in the vector</li>
</ul>
</li>
</ul>
<p>Again, expressed as code:</p>
<pre>function VectorClock(value) {
  // expressed as a hash keyed by node id: e.g. { node1: 1, node2: 3 }
  this.value = value || {};
}

VectorClock.prototype.get = function() {
  return this.value;
};

VectorClock.prototype.increment = function(nodeId) {
  if(typeof this.value[nodeId] == &#39;undefined&#39;) {
    this.value[nodeId] = 1;
  } else {
    this.value[nodeId]++;
  }
};

VectorClock.prototype.merge = function(other) {
  var result = {}, last,
      a = this.value,
      b = other.value;
  // This filters out duplicate keys in the hash
  (Object.keys(a)
    .concat(b))
    .sort()
    .filter(function(key) {
      var isDuplicate = (key == last);
      last = key;
      return !isDuplicate;
    }).forEach(function(key) {
      result[key] = Math.max(a[key] || 0, b[key] || 0);
    });
  this.value = result;
};</pre>
<p>This illustration (<a href="http://en.wikipedia.org/wiki/Vector_clock">source</a>) shows a vector clock:</p>
<p class="img-container"><img src="images/vector_clock.svg.png" alt="from http://en.wikipedia.org/wiki/Vector_clock"></p>
<p>Each of the three nodes (A, B, C) keeps track of the vector clock. As events occur, they are timestamped with the current value of the vector clock. Examining a vector clock such as <code>{ A: 2, B: 4, C: 1 }</code> lets us accurately identify the messages that (potentially) influenced that event.</p>
<p>The issue with vector clocks is mainly that they require one entry per node, which means that they can potentially become very large for large systems. A variety of techniques have been applied to reduce the size of vector clocks (either by performing periodic garbage collection, or by reducing accuracy by limiting the size).</p>
<p>We&#39;ve looked at how order and causality can be tracked without physical clocks. Now, let&#39;s look at how time durations can be used for cutoff.</p>
<h2>Failure detectors (time for cutoff)</h2>
<p>As I stated earlier, the amount of time spent waiting can provide clues about whether a system is partitioned or merely experiencing high latency. In this case, we don&#39;t need to assume a global clock of perfect accuracy - it is simply enough that there is a reliable-enough local clock.</p>
<p>Given a program running on one node, how can it tell that a remote node has failed? In the absence of accurate information, we can infer that an unresponsive remote node has failed after some reasonable amount of time has passed.</p>
<p>But what is a &quot;reasonable amount&quot;? This depends on the latency between the local and remote nodes. Rather than explicitly specifying algorithms with specific values (which would inevitably be wrong in some cases), it would be nicer to deal with a suitable abstraction.</p>
<p>A failure detector is a way to abstract away the exact timing assumptions. Failure detectors are implemented using heartbeat messages and timers. Processes exchange heartbeat messages. If a message response is not received before the timeout occurs, then the process suspects the other process.</p>
<p>A failure detector based on a timeout will carry the risk of being either overly aggressive (declaring a node to have failed) or being overly conservative (taking a long time to detect a crash). How accurate do failure detectors need to be for them to be usable?</p>
<p><a href="http://www.google.com/search?q=Unreliable%20Failure%20Detectors%20for%20Reliable%20Distributed%20Systems">Chandra et al.</a> (1996) discuss failure detectors in the context of solving consensus - a problem that is particularly relevant since it underlies most replication problems where the replicas need to agree in environments with latency and network partitions.</p>
<p>They characterize failure detectors using two properties, completeness and accuracy:</p>
<dl>
  <dt>Strong completeness.</dt>
  <dd>Every crashed process is eventually suspected by every correct process.</dd>
  <dt>Weak completeness.</dt>
  <dd>Every crashed process is eventually suspected by some correct process.</dd>
  <dt>Strong accuracy.</dt>
  <dd>No correct process is suspected ever.</dd>
  <dt>Weak accuracy.</dt>
  <dd>Some correct process is never suspected.</dd>
</dl>

<p>Completeness is easier to achieve than accuracy; indeed, all failure detectors of importance achieve it - all you need to do is not to wait forever to suspect someone. Chandra et al. note that a failure detector with weak completeness can be transformed to one with strong completeness (by broadcasting information about suspected processes), allowing us to concentrate on the spectrum of accuracy properties.</p>
<p>Avoiding incorrectly suspecting non-faulty processes is hard unless you are able to assume that there is a hard maximum on the message delay. That assumption can be made in a synchronous system model - and hence failure detectors can be strongly accurate in such a system. Under system models that do not impose hard bounds on message delay, failure detection can at best be eventually accurate.</p>
<p>Chandra et al. show that even a very weak failure detector - the eventually weak failure detector âW (eventually weak accuracy + weak completeness) - can be used to solve the consensus problem. The diagram below (from the paper) illustrates the relationship between system models and problem solvability:</p>
<p class="img-container"><img src="images/chandra_failure_detectors.png" alt="From Chandra and Toueg. Unreliable failure detectors for reliable distributed systems. JACM 43(2):225â267, 1996."></p>
<p>As you can see above, certain problems are not solvable without a failure detector in asynchronous systems. This is because without a failure detector (or strong assumptions about time bounds e.g. the synchronous system model), it is not possible to tell whether a remote node has crashed, or is simply experiencing high latency. That distinction is important for any system that aims for single-copy consistency: failed nodes can be ignored because they cannot cause divergence, but partitioned nodes cannot be safely ignored.</p>
<p>How can one implement a failure detector? Conceptually, there isn&#39;t much to a simple failure detector, which simply detects failure when a timeout expires. The most interesting part relates to how the judgments are made about whether a remote node has failed.</p>
<p>Ideally, we&#39;d prefer the failure detector to be able to adjust to changing network conditions and to avoid hardcoding timeout values into it. For example, Cassandra uses an <a href="https://www.google.com/search?q=The+Phi+accrual+failure+detector">accrual failure detector</a>, which is a failure detector that outputs a suspicion level (a value between 0 and 1) rather than a binary &quot;up&quot; or &quot;down&quot; judgment. This allows the application using the failure detector to make its own decisions about the tradeoff between accurate detection and early detection.</p>
<h2>Time, order and performance</h2>
<p>Earlier, I alluded to having to pay the cost for order. What did I mean?</p>
<p>If you&#39;re writing a distributed system, you presumably own more than one computer. The natural (and realistic) view of the world is a partial order, not a total order. You can transform a partial order into a total order, but this requires communication, waiting and imposes restrictions that limit how many computers can do work at any particular point in time.</p>
<p>All clocks are mere approximations bound by either network latency (logical time) or by physics. Even keeping a simple integer counter in sync across multiple nodes is a challenge.</p>
<p>While time and order are often discussed together, time itself is not such a useful property. Algorithms don&#39;t really care about time as much as they care about more abstract properties:</p>
<ul class="list">
<li>the causal ordering of events</li>
<li>failure detection (e.g. approximations of upper bounds on message delivery)</li>
<li>consistent snapshots (e.g. the ability to examine the state of a system at some point in time; not discussed here)</li>
</ul>
<p>Imposing a total order is possible, but expensive. It requires you to proceed at the common (lowest) speed. Often the easiest way to ensure that events are delivered in some defined order is to nominate a single (bottleneck) node through which all operations are passed.</p>
<p>Is time / order / synchronicity really necessary? It depends. In some use cases, we want each intermediate operation to move the system from one consistent state to another. For example, in many cases we want the responses from a database to represent all of the available information, and we want to avoid dealing with the issues that might occur if the system could return an inconsistent result.</p>
<p>But in other cases, we might not need that much time / order / synchronization. For example, if you are running a long running computation, and don&#39;t really care about what the system does until the very end - then you don&#39;t really need much synchronization as long as you can guarantee that the answer is correct.</p>
<p>Synchronization is often applied as a blunt tool across all operations, when only a subset of cases actually matter for the final outcome. When is order needed to guarantee correctness? The CALM theorem - which I will discuss in the last chapter - provides one answer.</p>
<p>In other cases, it is acceptable to give an answer that only represents the best known estimate - that is, is based on only a subset of the total information contained in the system. In particular, during a network partition one may need to answer queries with only a part of the system being accessible. In other use cases, the end user cannot really distinguish between a relatively recent answer that can be obtained cheaply and one that is guaranteed to be correct and is expensive to calculate. For example, is the Twitter follower count for some user X, or X+1? Or are movies A, B and C the absolutely best answers for some query? Doing a cheaper, mostly correct &quot;best effort&quot; can be acceptable.</p>
<p>In the next two chapters we&#39;ll examine replication for fault-tolerant strongly consistent systems - systems which provide strong guarantees while being increasingly resilient to failures. These systems provide solutions for the first case: when you need to guarantee correctness and are willing to pay for it. Then, we&#39;ll discuss systems with weak consistency guarantees, which can remain available in the face of partitions, but that can only give you a &quot;best effort&quot; answer.</p>
<hr>
<h2>Further reading</h2>
<h3>Lamport clocks, vector clocks</h3>
<ul class="list">
<li><a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">Time, Clocks and Ordering of Events in a Distributed System</a> - Leslie Lamport, 1978</li>
</ul>
<h3>Failure detection</h3>
<ul class="list">
<li><a href="http://scholar.google.com/scholar??q=Unreliable+Failure+Detectors+for+Reliable+Distributed+Systems">Unreliable failure detectors and reliable distributed systems</a> - Chandra and Toueg</li>
<li><a href="http://www.cs.cornell.edu/people/egs/sqrt-s/doc/TR2006-2025.pdf">Latency- and Bandwidth-Minimizing Optimal Failure Detectors</a> - So &amp; Sirer, 2007</li>
<li><a href="http://scholar.google.com/scholar?q=The+failure+detector+abstraction">The failure detector abstraction</a>, Freiling, Guerraoui &amp; Kuznetsov, 2011</li>
</ul>
<h3>Snapshots</h3>
<ul class="list">
<li><a href="http://scholar.google.com/scholar?q=Consistent+global+states+of+distributed+systems%3A+Fundamental+concepts+and+mechanisms">Consistent global states of distributed systems: Fundamental concepts and mechanisms</a>, Ozalp Babaogly and Keith Marzullo, 1993</li>
<li><a href="http://scholar.google.com/scholar?q=Distributed+snapshots%3A+Determining+global+states+of+distributed+systems">Distributed snapshots: Determining global states of distributed systems</a>, K. Mani Chandy and Leslie Lamport, 1985</li>
</ul>
<h3>Causality</h3>
<ul class="list">
<li><a href="http://www.vs.inf.ethz.ch/publ/papers/holygrail.pdf">Detecting Causal Relationships in Distributed Computations: In Search of the Holy Grail</a> - Schwarz &amp; Mattern, 1994</li>
<li><a href="http://scholar.google.com/scholar?q=Understanding+the+limitations+of+causally+and+totally+ordered+communication">Understanding the Limitations of Causally and Totally Ordered Communication</a> - Cheriton &amp; Skeen, 1993</li>
</ul>
<div style="page-break-after: always;"></div><a name="replication"></a><h1>4. Replication</h1>
<p>The replication problem is one of many problems in distributed systems. I&#39;ve chosen to focus on it over other problems such as leader election, failure detection, mutual exclusion, consensus and global snapshots because it is often the part that people are most interested in. One way in which parallel databases are differentiated is in terms of their replication features, for example. Furthermore, replication provides a context for many subproblems, such as leader election, failure detection, consensus and atomic broadcast.</p>
<p>Replication is a group communication problem. What arrangement and communication pattern gives us the performance and availability characteristics we desire? How can we ensure fault tolerance, durability and non-divergence in the face of network partitions and simultaneous node failure?</p>
<p>Again, there are many ways to approach replication. The approach I&#39;ll take here just looks at high level patterns that are possible for a system with replication. Looking at this visually helps keep the discussion focused on the overall pattern rather than the specific messaging involved. My goal here is to explore the design space rather than to explain the specifics of each algorithm.</p>
<p>Let&#39;s first define what replication looks like. We assume that we have some initial database, and that clients make requests which change the state of the database.</p>
<p class="img-container"><img src="images/replication-both.png" alt="replication" style="height: 340px;"></p>
<p>The arrangement and communication pattern can then be divided into several stages:</p>
<ol class="list">
<li>(Request) The client sends a request to a server</li>
<li>(Sync) The synchronous portion of the replication takes place</li>
<li>(Response) A response is returned to the client</li>
<li>(Async) The asynchronous portion of the replication takes place</li>
</ol>
<p>This model is loosely based on <a href="https://www.google.com/search?q=understanding+replication+in+databases+and+distributed+systems">this article</a>. Note that the pattern of messages exchanged in each portion of the task depends on the specific algorithm: I am intentionally trying to get by without discussing the specific algorithm.</p>
<p>Given these stages, what kind of communication patterns can we create? And what are the performance and availability implications of the patterns we choose?</p>
<h2>Synchronous replication</h2>
<p>The first pattern is synchronous replication (also known as active, or eager, or push, or pessimistic replication). Let&#39;s draw what that looks like:</p>
<p class="img-container"><img src="images/replication-sync.png" alt="replication" style="height: 340px;"></p>
<p>Here, we can see three distinct stages: first, the client sends the request. Next, what we called the synchronous portion of replication takes place. The term refers to the fact that the client is blocked - waiting for a reply from the system.</p>
<p>During the synchronous phase, the first server contacts the two other servers and waits until it has received replies from all the other servers. Finally, it sends a response to the client informing it of the result (e.g. success or failure).</p>
<p>All this seems straightforward. What can we say of this specific arrangement of communication patterns, without discussing the details of the algorithm during the synchronous phase? First, observe that this is a write N - of - N approach: before a response is returned, it has to be seen and acknowledged by every server in the system.</p>
<p>From a performance perspective, this means that the system will be as fast as the slowest server in it. The system will also be very sensitive to changes in network latency, since it requires every server to reply before proceeding.</p>
<p>Given the N-of-N approach, the system cannot tolerate the loss of any servers. When a server is lost, the system can no longer write to all the nodes, and so it cannot proceed. It might be able to provide read-only access to the data, but modifications are not allowed after a node has failed in this design.</p>
<p>This arrangement can provide very strong durability guarantees: the client can be certain that all N servers have received, stored and acknowledged the request when the response is returned. In order to lose an accepted update, all N copies would need to be lost, which is about as good a guarantee as you can make.</p>
<h2>Asynchronous replication</h2>
<p>Let&#39;s contrast this with the second pattern - asynchronous replication (a.k.a. passive replication, or pull replication, or lazy replication). As you may have guessed, this is the opposite of synchronous replication:</p>
<p class="img-container"><img src="images/replication-async.png" alt="replication" style="height: 340px;"></p>
<p>Here, the master (/leader / coordinator) immediately sends back a response to the client. It might at best store the update locally, but it will not do any significant work synchronously and the client is not forced to wait for more rounds of communication to occur between the servers.</p>
<p>At some later stage, the asynchronous portion of the replication task takes place. Here, the master contacts the other servers using some communication pattern, and the other servers update their copies of the data. The specifics depend on the algorithm in use.</p>
<p>What can we say of this specific arrangement without getting into the details of the algorithm? Well, this is a write 1 - of - N approach: a response is returned immediately and update propagation occurs sometime later.</p>
<p>From a performance perspective, this means that the system is fast: the client does not need to spend any additional time waiting for the internals of the system to do their work. The system is also more tolerant of network latency, since fluctuations in internal latency do not cause additional waiting on the client side.</p>
<p>This arrangement can only provide weak, or probabilistic durability guarantees. If nothing goes wrong, the data is eventually replicated to all N machines. However, if the only server containing the data is lost before this can take place, the data is permanently lost.</p>
<p>Given the 1-of-N approach, the system can remain available as long as at least one node is up (at least in theory, though in practice the load will probably be too high). A purely lazy approach like this provides no durability or consistency guarantees; you may be allowed to write to the system, but there are no guarantees that you can read back what you wrote if any faults occur.</p>
<p>Finally, it&#39;s worth noting that passive replication cannot ensure that all nodes in the system always contain the same state. If you accept writes at multiple locations and do not require that those nodes synchronously agree, then you will run the risk of divergence: reads may return different results from different locations (particularly after nodes fail and recover), and global constraints (which require communicating with everyone) cannot be enforced.</p>
<p>I haven&#39;t really mentioned the communication patterns during a read (rather than a write), because the pattern of reads really follows from the pattern of writes: during a read, you want to contact as few nodes as possible. We&#39;ll discuss this a bit more in the context of quorums.</p>
<p>We&#39;ve only discussed two basic arrangements and none of the specific algorithms. Yet we&#39;ve been able to figure out quite a bit of about the possible communication patterns as well as their performance, durability guarantees and availability characteristics.</p>
<h2>An overview of major replication approaches</h2>
<p>Having discussed the two basic replication approaches: synchronous and asynchronous replication, let&#39;s have a look at the major replication algorithms.</p>
<p>There are many, many different ways to categorize replication techniques. The second distinction (after sync vs. async) I&#39;d like to introduce is between:</p>
<ul class="list">
<li>Replication methods that prevent divergence (single copy systems) and</li>
<li>Replication methods that risk divergence (multi-master systems)</li>
</ul>
<p>The first group of methods has the property that they &quot;behave like a single system&quot;. In particular, when partial failures occur, the system ensures that only a single copy of the system is active. Furthermore, the system ensures that the replicas are always in agreement. This is known as the consensus problem.</p>
<p>Several processes (or computers) achieve consensus if they all agree on some value. More formally:</p>
<ol class="list">
<li>Agreement: Every correct process must agree on the same value.</li>
<li>Integrity: Every correct process decides at most one value, and if it decides some value, then it must have been proposed by some process.</li>
<li>Termination: All processes eventually reach a decision.</li>
<li>Validity: If all correct processes propose the same value V, then all correct processes decide V.</li>
</ol>
<p>Mutual exclusion, leader election, multicast and atomic broadcast are all instances of the more general problem of consensus. Replicated systems that maintain single copy consistency need to solve the consensus problem in some way.</p>
<p>The replication algorithms that maintain single-copy consistency include:</p>
<ul class="list">
<li>1n messages (asynchronous primary/backup)</li>
<li>2n messages (synchronous primary/backup)</li>
<li>4n messages (2-phase commit, Multi-Paxos)</li>
<li>6n messages (3-phase commit, Paxos with repeated leader election)</li>
</ul>
<p>These algorithms vary in their fault tolerance (e.g. the types of faults they can tolerate). I&#39;ve classified these simply by the number of messages exchanged during an execution of the algorithm, because I think it is interesting to try to find an answer to the question &quot;what are we buying with the added message exchanges?&quot;</p>
<p>The diagram below, adapted from Ryan Barret at <a href="http://www.google.com/events/io/2009/sessions/TransactionsAcrossDatacenters.html">Google</a>, describes some of the aspects of the different options:</p>
<p class="img-container"><img src="images/google-transact09.png" alt="Comparison of replication methods, from http://www.google.com/events/io/2009/sessions/TransactionsAcrossDatacenters.html"></p>
<p>The consistency, latency, throughput, data loss and failover characteristics in the diagram above can really be traced back to the two different replication methods: synchronous replication (e.g. waiting before responding) and asynchronous replication. When you wait, you get worse performance but stronger guarantees. The throughput difference between 2PC and quorum systems will become apparent when we discuss partition (and latency) tolerance.</p>
<p>In that diagram, algorithms enforcing weak (/eventual) consistency are lumped up into one category (&quot;gossip&quot;). However, I will discuss replication methods for weak consistency - gossip and (partial) quorum systems - in more detail. The &quot;transactions&quot; row really refers more to global predicate evaluation, which is not supported in systems with weak consistency (though local predicate evaluation can be supported).</p>
<p>It is worth noting that systems enforcing weak consistency requirements have fewer generic algorithms, and more techniques that can be selectively applied. Since systems that do not enforce single-copy consistency are free to act like distributed systems consisting of multiple nodes, there are fewer obvious objectives to fix and the focus is more on giving people a way to reason about the characteristics of the system that they have.</p>
<p>For example:</p>
<ul class="list">
<li>Client-centric consistency models attempt to provide more intelligible consistency guarantees while allowing for divergence.</li>
<li>CRDTs (convergent replicated datatypes) exploit knowledge regarding the commutativity (and associativity) of specific operations on specific datatypes.</li>
<li>Confluence analysis (as in the Bloom language) uses information regarding the monotonicity of computations to maximally exploit disorder.</li>
<li>PBS (probabilistically bound staleness) uses simulation and information collected from a real world system to characterize the expected behavior of partial quorum systems.</li>
</ul>
<p>I&#39;ll talk about all of these a bit  further on, first; let&#39;s look at the replication algorithms that maintain single-copy consistency.</p>
<h2>Primary/backup replication</h2>
<p>Primary/backup replication (also known as primary copy replication master-slave replication or log shipping) is perhaps the most commonly used replication method, and the most basic algorithm. All updated are performed on the primary, and a log of operations (or alternatively, changes) is shipped across the network to the backup replicas. There are two variants:</p>
<ul class="list">
<li>asynchronous primary/backup replication and</li>
<li>synchronous primary/backup replication</li>
</ul>
<p>The synchronous version requires two messages (&quot;update&quot; + &quot;acknowledge receipt&quot;) while the asynchronous version could run with just one (&quot;update&quot;).</p>
<p>P/B is very common. For example, by default MySQL replication uses the asynchronous variant. MongoDB also uses P/B (with some additional procedures for failover). All operations are performed on one master server, which serializes them to a local log, which is then replicated asynchronously to the backup servers.</p>
<p>As we discussed earlier in the context of asynchronous replication, any asynchronous replication algorithm can only provide weak durability guarantees. In MySQL replication this manifests as replication lag: the asynchronous backups are always at least one operation behind the primary. If the primary fails, then the updates that have not yet been sent to the backups are lost.</p>
<p>The synchronous variant of primary/backup replication ensures that writes have been stored on other nodes before returning back to the client - at the cost of waiting for responses from other replicas. However, it is worth noting that even this variant can only offer weak guarantees. Consider the following simple failure scenario:</p>
<ul class="list">
<li>the primary receives a write and sends it to the backup</li>
<li>the backup persists and ACKs the write</li>
<li>and then primary fails before sending ACK to the client</li>
</ul>
<p>The client now assumes that the commit failed, but the backup committed it; if the backup is promoted to primary, it will be incorrect. Manual cleanup may be needed to reconcile the failed primary or divergent backups.</p>
<p>I am simplifying here of course. While all primary/backup replication algorithms follow the same general messaging pattern, they differ in their handling of failover, replicas being offline for extended periods and so on. However, it is not possible to be resilient to inopportune failures of the primary in this scheme.</p>
<p>What is key in the log-shipping / primary/backup based schemes is that they can only offer a best-effort guarantee (e.g. they are susceptible to lost updates or incorrect updates if nodes fail at inopportune times). Furthermore, P/B schemes are susceptible to split-brain, where the failover to a backup kicks in due to a temporary network issue and causes both the primary and backup to be active at the same time.</p>
<p>To prevent inopportune failures from causing consistency guarantees to be violated; we need to add another round of messaging, which gets us the two phase commit protocol (2PC).</p>
<h2>Two phase commit (2PC)</h2>
<p><a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol">Two phase commit</a> (2PC) is a protocol used in many classic relational databases. For example, MySQL Cluster (not to be confused with the regular MySQL) provides synchronous replication using 2PC. The diagram below illustrates the message flow:</p>
<pre>[ Coordinator ] -&gt; OK to commit?     [ Peers ]
                &lt;- Yes / No

[ Coordinator ] -&gt; Commit / Rollback [ Peers ]
                &lt;- ACK</pre>
<p>In the first phase (voting), the coordinator sends the update to all the participants. Each participant processes the update and votes whether to commit or abort. When voting to commit, the participants store the update onto a temporary area (the write-ahead log). Until the second phase completes, the update is considered temporary.</p>
<p>In the second phase (decision), the coordinator decides the outcome and informs every participant about it. If all participants voted to commit, then the update is taken from the temporary area and made permanent.</p>
<p>Having a second phase in place before the commit is considered permanent is useful, because it allows the system to roll back an update when a node fails. In contrast, in primary/backup (&quot;1PC&quot;), there is no step for rolling back an operation that has failed on some nodes and succeeded on others, and hence the replicas could diverge.</p>
<p>2PC is prone to blocking, since a single node failure (participant or coordinator) blocks progress until the node has recovered. Recovery is often possible thanks to the second phase, during which other nodes are informed about the system state. Note that 2PC assumes that the data in stable storage at each node is never lost and that no node crashes forever. Data loss is still possible if the data in the stable storage is corrupted in a crash.</p>
<p>The details of the recovery procedures during node failures are quite complicated so I won&#39;t get into the specifics. The major tasks are ensuring that writes to disk are durable (e.g. flushed to disk rather than cached) and making sure that the right recovery decisions are made (e.g. learning the outcome of the round and then redoing or undoing an update locally).</p>
<p>As we learned in the chapter regarding CAP, 2PC is a CA - it is not partition tolerant. The failure model that 2PC addresses does not include network partitions; the prescribed way to recover from a node failure is to wait until the network partition heals. There is no safe way to promote a new coordinator if one fails; rather a manual intervention is required. 2PC is also fairly latency-sensitive, since it is a write N-of-N approach in which writes cannot proceed until the slowest node acknowledges them.</p>
<p>2PC strikes a decent balance between performance and fault tolerance, which is why it has been popular in relational databases. However, newer systems often use a partition tolerant consensus algorithm, since such an algorithm can provide automatic recovery from temporary network partitions as well as more graceful handling of increased between-node latency.</p>
<p>Let&#39;s look at partition tolerant consensus algorithms next.</p>
<h2>Partition tolerant consensus algorithms</h2>
<p>Partition tolerant consensus algorithms are as far as we&#39;re going to go in terms of fault-tolerant algorithms that maintain single-copy consistency. There is a further class of fault tolerant algorithms: algorithms that tolerate <a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance">arbitrary (Byzantine) faults</a>; these include nodes that fail by acting maliciously. Such algorithms are rarely used in commercial systems, because they are more expensive to run and more complicated to implement - and hence I will leave them out.</p>
<p>When it comes to partition tolerant consensus algorithms, the most well-known algorithm is the Paxos algorithm. It is, however, notoriously difficult to implement and explain, so I will focus on Raft, a recent (~early 2013) algorithm designed to be easier to teach and implement. Let&#39;s first take a look at network partitions and the general characteristics of partition tolerant consensus algorithms.</p>
<h3>What is a network partition?</h3>
<p>A network partition is the failure of a network link to one or several nodes. The nodes themselves continue to stay active, and they may even be able to receive requests from clients on their side of the network partition. As we learned earlier - during the discussion of the CAP theorem - network partitions do occur and not all systems handle them gracefully.</p>
<p>Network partitions are tricky because during a network partition, it is not possible to distinguish between a failed remote node and the node being unreachable. If a network partition occurs but no nodes fail, then the system is divided into two partitions which are simultaneously active. The two diagrams below illustrate how a network partition can look similar to a node failure.</p>
<p>A system of 2 nodes, with a failure vs. a network partition:</p>
<p class="img-container"><img src="images/system-of-2.png" alt="replication" style="max-height: 100px;"></p>
<p>A system of 3 nodes, with a failure vs. a network partition:</p>
<p class="img-container"><img src="images/system-of-3.png" alt="replication"  style="max-height: 130px;"></p>
<p>A system that enforces single-copy consistency must have some method to break symmetry: otherwise, it will split into two separate systems, which can diverge from each other and can no longer maintain the illusion of a single copy.</p>
<p>Network partition tolerance for systems that enforce single-copy consistency requires that during a network partition, only one partition of the system remains active since during a network partition it is not possible to prevent divergence (e.g. CAP theorem).</p>
<h3>Majority decisions</h3>
<p>This is why partition tolerant consensus algorithms rely on a majority vote. Requiring a majority of nodes - rather than all of the nodes (as in 2PC) - to agree on updates allows a minority of the nodes to be down, or slow, or unreachable due to a network partition. As long as <code>(N/2 + 1)-of-N</code> nodes are up and accessible, the system can continue to operate.</p>
<p>Partition tolerant consensus algorithms use an odd number of nodes (e.g. 3, 5 or 7). With just two nodes, it is not possible to have a clear majority after a failure. For example, if the number of nodes is three, then the system is resilient to one node failure; with five nodes the system is resilient to two node failures.</p>
<p>When a network partition occurs, the partitions behave asymmetrically. One partition will contain the majority of the nodes. Minority partitions will stop processing operations to prevent divergence during a network partition, but the majority partition can remain active. This ensures that only a single copy of the system state remains active.</p>
<p>Majorities are also useful because they can tolerate disagreement: if there is a perturbation or failure, the nodes may vote differently. However, since there can be only one majority decision, a temporary disagreement can at most block the protocol from proceeding (giving up liveness) but it cannot violate the single-copy consistency criterion (safety property).</p>
<h3>Roles</h3>
<p>There are two ways one might structure a system: all nodes may have the same responsibilities, or nodes may have separate, distinct roles.</p>
<p>Consensus algorithms for replication generally opt for having distinct roles for each node. Having a single fixed leader or master server is an optimization that makes the system more efficient, since we know that all updates must pass through that server. Nodes that are not the leader just need to forward their requests to the leader.</p>
<p>Note that having distinct roles does not preclude the system from recovering from the failure of the leader (or any other role). Just because roles are fixed during normal operation doesn&#39;t mean that one cannot recover from failure by reassigning the roles after a failure (e.g. via a leader election phase). Nodes can reuse the result of a leader election until node failures and/or network partitions occur.</p>
<p>Both Paxos and Raft make use of distinct node roles. In particular, they have a leader node (&quot;proposer&quot; in Paxos) that is responsible for coordination during normal operation. During normal operation, the rest of the nodes are followers (&quot;acceptors&quot; or &quot;voters&quot; in Paxos).</p>
<h3>Epochs</h3>
<p>Each period of normal operation in both Paxos and Raft is called an epoch (&quot;term&quot; in Raft). During each epoch only one node is the designated leader (a similar system is <a href="http://en.wikipedia.org/wiki/Japanese_era_name">used in Japan</a> where era names change upon imperial succession).</p>
<p class="img-container"><img src="images/epoch.png" alt="replication"  style="max-height: 130px;"></p>
<p>After a successful election, the same leader coordinates until the end of the epoch. As shown in the diagram above (from the Raft paper), some elections may fail, causing the epoch to end immediately.</p>
<p>Epochs act as a logical clock, allowing other nodes to identify when an outdated node starts communicating - nodes that were partitioned or out of operation will have a smaller epoch number than the current one, and their commands are ignored.</p>
<h3>Leader changes via duels</h3>
<p>During normal operation, a partition-tolerant consensus algorithm is rather simple. As we&#39;ve seen earlier, if we didn&#39;t care about fault tolerance, we could just use 2PC. Most of the complexity really arises from ensuring that once a consensus decision has been made, it will not be lost and the protocol can handle leader changes as a result of a network or node failure.</p>
<p>All nodes start as followers; one node is elected to be a leader at the start. During normal operation, the leader maintains a heartbeat which allows the followers to detect if the leader fails or becomes partitioned.</p>
<p>When a node detects that a leader has become non-responsive (or, in the initial case, that no leader exists), it switches to an intermediate state (called &quot;candidate&quot; in Raft) where it increments the term/epoch value by one, initiates a leader election and competes to become the new leader.</p>
<p>In order to be elected a leader, a node must receive a majority of the votes. One way to assign votes is to simply assign them on a first-come-first-served basis; this way, a leader will eventually be elected. Adding a random amount of waiting time between attempts at getting elected will reduce the number of nodes that are simultaneously attempting to get elected.</p>
<h3>Numbered proposals within an epoch</h3>
<p>During each epoch, the leader proposes one value at a time to be voted upon. Within each epoch, each proposal is numbered with a unique strictly increasing number. The followers (voters / acceptors) accept the first proposal they receive for a particular proposal number.</p>
<h3>Normal operation</h3>
<p>During normal operation, all proposals go through the leader node. When a client submits a proposal (e.g. an update operation), the leader contacts all nodes in the quorum. If no competing proposals exist (based on the responses from the followers), the leader proposes the value. If a majority of the followers accept the value, then the value is considered to be accepted.</p>
<p>Since it is possible that another node is also attempting to act as a leader, we need to ensure that once a single proposal has been accepted, its value can never change. Otherwise a proposal that has already been accepted might for example be reverted by a competing leader. Lamport states this as:</p>
<blockquote>
<p>P2: If a proposal with value <code>v</code> is chosen, then every higher-numbered proposal that is chosen has value <code>v</code>.</p>
</blockquote>
<p>Ensuring that this property holds requires that both followers and proposers are constrained by the algorithm from ever changing a value that has been accepted by a majority. Note that &quot;the value can never change&quot; refers to the value of a single execution (or run / instance / decision) of the protocol. A typical replication algorithm will run multiple executions of the algorithm, but most discussions of the algorithm focus on a single run to keep things simple. We want to prevent the decision history from being altered or overwritten.</p>
<p>In order to enforce this property, the proposers must first ask the followers for their (highest numbered) accepted proposal and value. If the proposer finds out that a proposal already exists, then it must simply complete this execution of the protocol, rather than making its own proposal. Lamport states this as:</p>
<blockquote>
<p>P2b. If a proposal with value <code>v</code> is chosen, then every higher-numbered proposal issued by any proposer has value <code>v</code>.</p>
</blockquote>
<p>More specifically:</p>
<blockquote>
<p>P2c. For any <code>v</code> and <code>n</code>, if a proposal with value <code>v</code> and number <code>n</code> is issued [by a leader], then there is a set <code>S</code> consisting of a majority of acceptors [followers] such that either (a) no acceptor in <code>S</code> has accepted any proposal numbered less than <code>n</code>, or (b) <code>v</code> is the value of the highest-numbered proposal among all proposals numbered less than <code>n</code> accepted by the followers in <code>S</code>.</p>
</blockquote>
<p>This is the core of the Paxos algorithm, as well as algorithms derived from it. The value to be proposed is not chosen until the second phase of the protocol. Proposers must sometimes simply retransmit a previously made decision to ensure safety (e.g. clause b in P2c) until they reach a point where they know that they are free to impose their own proposal value (e.g. clause a).</p>
<p>If multiple previous proposals exist, then the highest-numbered proposal value is proposed. Proposers may only attempt to impose their own value if there are no competing proposals at all.</p>
<p>To ensure that no competing proposals emerge between the time the proposer asks each acceptor about its most recent value, the proposer asks the followers not to accept proposals with lower proposal numbers than the current one.</p>
<p>Putting the pieces together, reaching a decision using Paxos requires two rounds of communication:</p>
<pre>[ Proposer ] -&gt; Prepare(n)                                [ Followers ]
             &lt;- Promise(n; previous proposal number
                and previous value if accepted a
                proposal in the past)

[ Proposer ] -&gt; AcceptRequest(n, own value or the value   [ Followers ]
                associated with the highest proposal number
                reported by the followers)
                &lt;- Accepted(n, value)</pre>
<p>The prepare stage allows the proposer to learn of any competing or previous proposals. The second phase is where either a new value or a previously accepted value is proposed. In some cases - such as if two proposers are active at the same time (dueling); if messages are lost; or if a majority of the nodes have failed - then no proposal is accepted by a majority. But this is acceptable, since the decision rule for what value to propose converges towards a single value (the one with the highest proposal number in the previous attempt).</p>
<p>Indeed, according to the FLP impossibility result, this is the best we can do: algorithms that solve the consensus problem must either give up safety or liveness when the guarantees regarding bounds on message delivery do not hold. Paxos gives up liveness: it may have to delay decisions indefinitely until a point in time where there are no competing leaders, and a majority of nodes accept a proposal. This is preferable to violating the safety guarantees.</p>
<p>Of course, implementing this algorithm is much harder than it sounds. There are many small concerns which add up to a fairly significant amount of code even in the hands of experts. These are issues such as:</p>
<ul class="list">
<li>practical optimizations:<ul class="list">
<li>avoiding repeated leader election via leadership leases (rather than heartbeats)</li>
<li>avoiding repeated propose messages when in a stable state where the leader identity does not change</li>
</ul>
</li>
<li>ensuring that followers and proposers do not lose items in stable storage and that results stored in stable storage are not subtly corrupted (e.g. disk corruption)</li>
<li>enabling cluster membership to change in a safe manner (e.g. base Paxos depends on the fact that majorities always intersect in one node, which does not hold if the membership can change arbitrarily)</li>
<li>procedures for bringing a new replica up to date in a safe and efficient manner after a crash, disk loss or when a new node is provisioned</li>
<li>procedures for snapshotting and garbage collecting the data required to guarantee safety after some reasonable period (e.g. balancing storage requirements and fault tolerance requirements)</li>
</ul>
<p>Google&#39;s <a href="http://labs.google.com/papers/paxos_made_live.html">Paxos Made Live</a> paper details some of these challenges.</p>
<h2>Partition-tolerant consensus algorithms: Paxos, Raft, ZAB</h2>
<p>Hopefully, this has given you a sense of how a partition-tolerant consensus algorithm works. I encourage you to read one of the papers in the further reading section to get a grasp of the specifics of the different algorithms.</p>
<p><em>Paxos</em>. Paxos is one of the most important algorithms when writing strongly consistent partition tolerant replicated systems. It is used in many of Google&#39;s systems, including the <a href="http://research.google.com/archive/chubby.html">Chubby lock manager</a> used by <a href="http://research.google.com/archive/bigtable.html">BigTable</a>/<a href="http://research.google.com/pubs/pub36971.html">Megastore</a>, the Google File System as well as <a href="http://research.google.com/archive/spanner.html">Spanner</a>.</p>
<p>Paxos is named after the Greek island of Paxos, and was originally presented by Leslie Lamport in a paper called &quot;The Part-Time Parliament&quot; in 1998. It is often considered to be difficult to implement, and there have been a series of papers from companies with considerable distributed systems expertise explaining further practical details (see the further reading). You might want to read Lamport&#39;s commentary on this issue <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos">here</a> and <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#paxos-simple">here</a>.</p>
<p>The issues mostly relate to the fact that Paxos is described in terms of a single round of consensus decision making, but an actual working implementation usually wants to run multiple rounds of consensus efficiently. This has led to the development of many <a href="http://en.wikipedia.org/wiki/Paxos_algorithm">extensions on the core protocol</a> that anyone interested in building a Paxos-based system still needs to digest. Furthermore, there are additional practical challenges such as how to facilitate cluster membership change.</p>
<p><em>ZAB</em>. ZAB - the Zookeeper Atomic Broadcast protocol is used in Apache Zookeeper. Zookeeper is a system which provides coordination primitives for distributed systems, and is used by many Hadoop-centric distributed systems for coordination (e.g. <a href="http://hbase.apache.org/">HBase</a>, <a href="http://storm-project.net/">Storm</a>, <a href="http://kafka.apache.org/">Kafka</a>). Zookeeper is basically the open source community&#39;s version of Chubby. Technically speaking atomic broadcast is a problem different from pure consensus, but it still falls under the category of partition tolerant algorithms that ensure strong consistency.</p>
<p><em>Raft</em>. Raft is a recent (2013) addition to this family of algorithms. It is designed to be easier to teach than Paxos, while providing the same guarantees. In particular, the different parts of the algorithm are more clearly separated and the paper also describes a mechanism for cluster membership change.</p>
<h2>Replication methods with strong consistency</h2>
<p>In this chapter, we took a look at replication methods that enforce strong consistency. Starting with a contrast between synchronous work and asynchronous work, we worked our way up to algorithms that are tolerant of increasingly complex failures. Here are some of the key characteristics of each of the algorithms:</p>
<h4>Primary/Backup</h4>
<ul class="list">
<li>Single, static master</li>
<li>Replicated log, slaves are not involved in executing operations</li>
<li>No bounds on replication delay</li>
<li>Not partition tolerant</li>
<li>Manual/ad-hoc failover, not fault tolerant, &quot;hot backup&quot;</li>
</ul>
<h4>2PC</h4>
<ul class="list">
<li>Unanimous vote: commit or abort</li>
<li>Static master</li>
<li>2PC cannot survive simultaneous failure of the coordinator and a node during a commit</li>
<li>Not partition tolerant, tail latency sensitive</li>
</ul>
<h4>Paxos</h4>
<ul class="list">
<li>Majority vote</li>
<li>Dynamic master</li>
<li>Robust to n/2-1 simultaneous failures as part of protocol</li>
<li>Less sensitive to tail latency</li>
</ul>
<hr>
<h2>Further reading</h2>
<h4>Primary-backup and 2PC</h4>
<ul class="list">
<li><a href="http://scholar.google.com/scholar?q=Replication+techniques+for+availability">Replication techniques for availability</a> - Robbert van Renesse &amp; Rachid Guerraoui, 2010</li>
<li><a href="http://research.microsoft.com/en-us/people/philbe/ccontrol.aspx">Concurrency Control and Recovery in Database Systems</a></li>
</ul>
<h4>Paxos</h4>
<ul class="list">
<li><a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf">The Part-Time Parliament</a> - Leslie Lamport</li>
<li><a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf">Paxos Made Simple</a> - Leslie Lamport, 2001</li>
<li><a href="http://research.google.com/archive/paxos_made_live.html">Paxos Made Live - An Engineering Perspective</a> - Chandra et al</li>
<li><a href="http://scholar.google.com/scholar?q=Paxos+Made+Practical">Paxos Made Practical</a> - Mazieres, 2007</li>
<li><a href="http://groups.csail.mit.edu/tds/paxos.html">Revisiting the Paxos Algorithm</a> - Lynch et al</li>
<li><a href="http://research.microsoft.com/lampson/58-Consensus/Acrobat.pdf">How to build a highly available system with consensus</a> - Butler Lampson</li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/reconfiguration-tutorial.pdf">Reconfiguring a State Machine</a> - Lamport et al - changing cluster membership</li>
<li><a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.4762">Implementing Fault-Tolerant Services Using the State Machine Approach: a Tutorial</a> - Fred Schneider</li>
</ul>
<h4>Raft and ZAB</h4>
<ul class="list">
<li><a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">In Search of an Understandable Consensus Algorithm</a>, Diego Ongaro, John Ousterhout, 2013</li>
<li><a href="http://research.yahoo.com/pub/3274">A simple totally ordered broadcast protocol</a> - Junqueira, Reed</li>
<li><a href="http://research.yahoo.com/pub/3514">ZooKeeper Atomic Broadcast</a></li>
</ul>
<div style="page-break-after: always;"></div><a name="eventual"></a><h1>5. Replication: weak consistency model protocols</h1>
<p>Now that we&#39;ve taken a look at protocols that can enforce single-copy consistency under an increasingly realistic set of supported failure cases, let&#39;s turn our attention at the world of options that opens up once we let go of the requirement of single-copy consistency.</p>
<p>By and large, it is hard to come up with a single dimension that defines or characterizes the protocols that allow for replicas to diverge. Most such protocols are highly available, and the key issue is more whether or not the end users find the guarantees, abstractions and APIs useful for their purpose in spite of the fact that the replicas may diverge when node and/or network failures occur.</p>
<p>Why haven&#39;t weakly consistent systems been more popular?</p>
<p>As I stated in the introduction, I think that much of distributed programming is about dealing with the implications of two consequences of distribution:</p>
<ul class="list">
<li>that information travels at the speed of light</li>
<li>that independent things fail independently</li>
</ul>
<p>The implication that follows from the limitation on the speed at which information travels is that nodes experience the world in different, unique ways. Computation on a single node is easy, because everything happens in a predictable global total order. Computation on a distributed system is difficult, because there is no global total order.</p>
<p>For the longest while (e.g. decades of research), we&#39;ve solved this problem by introducing a global total order. I&#39;ve discussed the many methods for achieving strong consistency by creating order (in a fault-tolerant manner) where there is no naturally occurring total order.</p>
<p>Of course, the problem is that enforcing order is expensive. This breaks down in particular with large scale internet systems, where a system needs to remain available. A system enforcing strong consistency doesn&#39;t behave like a distributed system: it behaves like a single system, which is bad for availability during a partition.</p>
<p>Furthermore, for each operation, often a majority of the nodes must be contacted - and often not just once, but twice (as you saw in the discussion on 2PC). This is particularly painful in systems that need to be geographically distributed to provide adequate performance for a global user base.</p>
<p>So behaving like a single system by default is perhaps not desirable.</p>
<p>Perhaps what we want is a system where we can write code that doesn&#39;t use expensive coordination, and yet returns a &quot;usable&quot; value. Instead of having a single truth, we will allow different replicas to diverge from each other - both to keep things efficient but also to tolerate partitions - and then try to find a way to deal with the divergence in some manner.</p>
<p>Eventual consistency expresses this idea: that nodes can for some time diverge from each other, but that eventually they will agree on the value.</p>
<p>Within the set of systems providing eventual consistency, there are two types of system designs:</p>
<p><em>Eventual consistency with probabilistic guarantees</em>. This type of system can detect conflicting writes at some later point, but does not guarantee that the results are equivalent to some correct sequential execution. In other words, conflicting updates will sometimes result in overwriting a newer value with an older one and some anomalies can be expected to occur during normal operation (or during partitions).</p>
<p>In recent years, the most influential system design offering single-copy consistency is Amazon&#39;s Dynamo, which I will discuss as an example of a system that offers eventual consistency with probabilistic guarantees.</p>
<p><em>Eventual consistency with strong guarantees</em>. This type of system guarantees that the results converge to a common value equivalent to some correct sequential execution. In other words, such systems do not produce in anomalous results; without any coordination you can build replicas of the same service, and those replicas can communicate in any pattern and receive the updates in any order, and they will eventually agree on the end result as long as they all see the same information.</p>
<p>CRDT&#39;s (convergent replicated data types) are data types that guarantee convergence to the same value in spite of network delays, partitions and message reordering. They are provably convergent, but the data types that can be implemented as CRDT&#39;s are limited.</p>
<p>The CALM (consistency as logical monotonicity) conjecture is an alternative expression of the same principle: it equates logical monotonicity with convergence. If we can conclude that something is logically monotonic, then it is also safe to run without coordination. Confluence analysis - in particular, as applied for the Bloom programming language - can be used to guide programmer decisions about when and where to use the coordination techniques from strongly consistent systems and when it is safe to execute without coordination.</p>
<h2>Reconciling different operation orders</h2>
<p>What does a system that does not enforce single-copy consistency look like?  Let&#39;s try to make this more concrete by looking a few examples.</p>
<p>Perhaps the most obvious characteristic of systems that do not enforce single-copy consistency is that they allow replicas to diverge from each other. This means that there is no strictly defined pattern of communication: replicas can be separated from each other and yet continue to be available and accept writes.</p>
<p>Let&#39;s imagine a system of three replicas, each of which is partitioned from the others. For example, the replicas might be in different datacenters and for some reason unable to communicate. Each replica remains available during the partition, accepting both reads and writes from some set of clients:</p>
<pre>[Clients]   - &gt; [A]

--- Partition ---

[Clients]   - &gt; [B]

--- Partition ---

[Clients]   - &gt; [C]</pre>
<p>After some time, the partitions heal and the replica servers exchange information. They have received different updates from different clients and have diverged each other, so some sort of reconciliation needs to take place. What we would like to happen is that all of the replicas converge to the same result.</p>
<pre>[A] \
    --&gt; [merge]
[B] /     |
          |
[C] ----[merge]---&gt; result</pre>
<p>Another way to think about systems with weak consistency guarantees is to imagine a set of clients sending messages to two in some order. Because there is no coordination protocol that enforces a single total order, the messages can get delivered in different orders at the two replicas:</p>
<pre>[Clients]  --&gt; [A]  1, 2, 3
[Clients]  --&gt; [B]  2, 3, 1</pre>
<p>This is, in essence, the reason why we need coordination protocols. For example, assume that we are trying to concatenate a string and the operations in messages 1, 2 and 3 are:</p>
<pre>1: { operation: concat(&#39;Hello &#39;) }
2: { operation: concat(&#39;World&#39;) }
3: { operation: concat(&#39;!&#39;) }</pre>
<p>Then, without coordination, A will produce &quot;Hello World!&quot;, and B will produce &quot;World!Hello &quot;.</p>
<pre>A: concat(concat(concat(&#39;&#39;, &#39;Hello &#39;), &#39;World&#39;), &#39;!&#39;) = &#39;Hello World!&#39;
B: concat(concat(concat(&#39;&#39;, &#39;World&#39;), &#39;!&#39;), &#39;Hello &#39;) = &#39;World!Hello &#39;</pre>
<p>This is, of course, incorrect. Again, what we&#39;d like to happen is that the replicas converge to the same result.</p>
<p>Keeping these two examples in mind, let&#39;s look at Amazon&#39;s Dynamo first to establish a baseline, and then discuss a number of novel approaches to building systems with weak consistency guarantees, such as CRDT&#39;s and the CALM theorem.</p>
<h2>Amazon&#39;s Dynamo</h2>
<p>Amazon&#39;s Dynamo system design (2007) is probably the best-known system that offers weak consistency guarantees but high availability. It is the basis for many other real world systems, including LinkedIn&#39;s Voldemort, Facebook&#39;s Cassandra and Basho&#39;s Riak.</p>
<p>Dynamo is an eventually consistent, highly available key-value store. A key value store is like a large hash table: a client can set values via <code>set(key, value)</code> and retrieve them by key using <code>get(key)</code>. A Dynamo cluster consists of N peer nodes; each node has a set of keys which is it responsible for storing.</p>
<p>Dynamo prioritizes availability over consistency; it does not guarantee single-copy consistency. Instead, replicas may diverge from each other when values are written; when a key is read, there is a read reconciliation phase that attempts to reconcile differences between replicas before returning the value back to the client.</p>
<p>For many features on Amazon, it is more important to avoid outages than it is to ensure that data is perfectly consistent, as an outage can lead to lost business and a loss of credibility. Furthermore, if the data is not particularly important, then a weakly consistent system can provide better performance and higher availability at a lower cost than a traditional RDBMS.</p>
<p>Since Dynamo is a complete system design, there are many different parts to look at beyond the core replication task. The diagram below illustrates some of the tasks; notably, how a write is routed to a node and written to multiple replicas.</p>
<pre>[ Client ]
    |
( Mapping keys to nodes )
    |
    V
[ Node A ]
    |     \
( Synchronous replication task: minimum durability )
    |        \
[ Node B]  [ Node C ]
    A
    |
( Conflict detection; asynchronous replication task:
  ensuring that partitioned / recovered nodes recover )
    |
    V
[ Node D]</pre>
<p>After looking at how a write is initially accepted, we&#39;ll look at how conflicts are detected, as well as the asynchronous replica synchronization task. This task is needed because of the high availability design, in which nodes may be temporarily unavailable (down or partitioned). The replica synchronization task ensures that nodes can catch up fairly rapidly even after a failure.</p>
<h3>Consistent hashing</h3>
<p>Whether we are reading or writing, the first thing that needs to happen is that we need to locate where the data should live on the system. This requires some type of key-to-node mapping.</p>
<p>In Dynamo, keys are mapped to nodes using a hashing technique known as <a href="https://github.com/mixu/vnodehash">consistent hashing</a> (which I will not discuss in detail). The main idea is that a key can be mapped to a set of nodes responsible for it by a simple calculation on the client. This means that a client can locate keys without having to query the system for the location of each key; this saves system resources as hashing is generally faster than performing a remote procedure call.</p>
<h3>Partial quorums</h3>
<p>Once we know where a key should be stored, we need to do some work to persist the value. This is a synchronous task; the reason why we will immediately write the value onto multiple nodes is to provide a higher level of durability (e.g. protection from the immediate failure of a node).</p>
<p>Just like Paxos or Raft, Dynamo uses quorums for replication. However, Dynamo&#39;s quorums are sloppy (partial) quorums rather than strict (majority) quorums.</p>
<p>Informally, a strict quorum system is a quorum system with the property that any two quorums (sets) in the quorum system overlap. Requiring a majority to vote for an update before accepting it guarantees that only a single history is admitted since each majority quorum must overlap in at least one node. This was the property that Paxos, for example, relied on.</p>
<p>Partial quorums do not have that property; what this means is that a majority is not required and that different subsets of the quorum may contain different versions of the same data. The user can choose the number of nodes to write to and read from:</p>
<ul class="list">
<li>the user can choose some number W-of-N nodes required for a write to succeed; and</li>
<li>the user can specify the number of nodes (R-of-N) to be contacted during a read.</li>
</ul>
<p><code>W</code> and <code>R</code> specify the number of nodes that need to be involved to a write or a read. Writing to more nodes makes writes slightly slower but increases the probability that the value is not lost; reading from more nodes increases the probability that the value read is up to date.</p>
<p>The usual recommendation is that <code>R + W &gt; N</code>, because this means that the read and write quorums overlap in one node - making it less likely that a stale value is returned. A typical configuration is <code>N = 3</code> (e.g. a total of three replicas for each value); this means that the user can choose between:</p>
<pre> R = 1, W = 3;
 R = 2, W = 2 or
 R = 3, W = 1</pre>
<p>More generally, again assuming <code>R + W &gt; N</code>:</p>
<ul class="list">
<li><code>R = 1</code>, <code>W = N</code>: fast reads, slow writes</li>
<li><code>R = N</code>, <code>W = 1</code>: fast writes, slow reads</li>
<li><code>R = N/2</code> and <code>W = N/2 + 1</code>: favorable to both</li>
</ul>
<p>N is rarely more than 3, because keeping that many copies of large amounts of data around gets expensive!</p>
<p>As I mentioned earlier, the Dynamo paper has inspired many other similar designs. They all use the same partial quorum based replication approach, but with different defaults for N, W and R:</p>
<ul class="list">
<li>Basho&#39;s Riak (N = 3, R = 2, W = 2 default)</li>
<li>Linkedin&#39;s Voldemort (N = 2 or 3, R = 1, W = 1 default)</li>
<li>Apache&#39;s Cassandra (N = 3, R = 1, W = 1 default)</li>
</ul>
<p>There is another detail: when sending a read or write request, are all N nodes asked to respond (Riak), or only a number of nodes that meets the minimum (e.g. R or W; Voldemort). The &quot;send-to-all&quot; approach is faster and less sensitive to latency (since it only waits for the fastest R or W nodes of N) but also less efficient, while the &quot;send-to-minimum&quot; approach is more sensitive to latency (since latency communicating with a single node will delay the operation) but also more efficient (fewer messages / connections overall).</p>
<p>What happens when the read and write quorums overlap, e.g. (<code>R + W &gt; N</code>)? Specifically, it is often claimed that this results in &quot;strong consistency&quot;.</p>
<h3>Is R + W &gt; N the same as &quot;strong consistency&quot;?</h3>
<p>No.</p>
<p>It&#39;s not completely off base: a system where <code>R + W &gt; N</code> can detect read/write conflicts, since any read quorum and any write quorum share a member. E.g. at least one node is in both quorums:</p>
<pre>   1     2   N/2+1     N/2+2    N
  [...] [R]  [R + W]   [W]    [...]</pre>
<p>This guarantees that a previous write will be seen by a subsequent read. However, this only holds if the nodes in N never change. Hence, Dynamo doesn&#39;t qualify, because in Dynamo the cluster membership can change if nodes fail.</p>
<p>Dynamo is designed to be always writable. It has a mechanism which handles node failures by adding a different, unrelated server into the set of nodes responsible for certain keys when the original server is down. This means that the quorums are no longer guaranteed to always overlap. Even <code>R = W = N</code> would not qualify, since while the quorum sizes are equal to N, the nodes in those quorums can change during a failure. Concretely, during a partition, if a sufficient number of nodes cannot be reached, Dynamo will add new nodes to the quorum from unrelated but accessible nodes.</p>
<p>Furthermore, Dynamo doesn&#39;t handle partitions in the manner that a system enforcing a strong consistency model would: namely, writes are allowed on both sides of a partition, which means that for at least some time the system does not act as a single copy. So calling <code>R + W &gt; N</code> &quot;strongly consistent&quot; is misleading; the guarantees merely probabilistic - which is not what strong consistency refers to.</p>
<h3>Conflict detection and read repair</h3>
<p>Systems that allow replicas to diverge must have a way to eventually reconcile two different values. As briefly mentioned during the partial quorum approach, one way to do this is to detect conflicts at read time, and then apply some conflict resolution method. But how is this done?</p>
<p>In general, this is done by tracking the causal history of a piece of data by supplementing it with some metadata. Clients must keep the metadata information when they read data from the system, and must return back the metadata value when writing to the database.</p>
<p>We&#39;ve already encountered a method for doing this: vector clocks can be used to represent the history of a value. Indeed, this is what the original Dynamo design uses for detecting conflicts.</p>
<p>However, using vector clocks is not the only alternative. If you look at many practical system designs, you can deduce quite a bit about how they work by looking at the metadata that they track.</p>
<p><em>No metadata</em>. When a system does not track metadata, and only returns the value (e.g. via a client API), it cannot really do anything special about concurrent writes. A common rule is that the last writer wins: in other words, if two writers are writing at the same time, only the value from the slowest writer is kept around.</p>
<p><em>Timestamps</em>. Nominally, the value with the higher timestamp value wins. However, if time is not carefully synchronized, many odd things can happen where old data from a system with a faulty or fast clock overwrites newer values. Facebook&#39;s Cassandra is a Dynamo variant that uses timestamps instead of vector clocks.</p>
<p><em>Version numbers</em>. Version numbers may avoid some of the issues related with using timestamps. Note that the smallest mechanism that can accurately track causality when multiple histories are possible are vector clocks, not version numbers.</p>
<p><em>Vector clocks</em>. Using vector clocks, concurrent and out of date updates can be detected. Performing read repair then becomes possible, though in some cases (concurrent changes) we need to ask the client to pick a value. This is because if the changes are concurrent and we know nothing more about the data (as is the case with a simple key-value store), then it is better to ask than to discard data arbitrarily.</p>
<p>When reading a value, the client contacts <code>R</code> of <code>N</code> nodes and asks them for the latest value for a key. It takes all the responses, discards the values that are strictly older (using the vector clock value to detect this). If there is only one unique vector clock + value pair, it returns that. If there are multiple vector clock + value pairs that have been edited concurrently (e.g. are not comparable), then all of those values are returned.</p>
<p>As is obvious from the above, read repair may return multiple values. This means that the client / application developer must occasionally handle these cases by picking a value based on some use-case specific criterion.</p>
<p>In addition, a key component of a practical vector clock system is that the clocks cannot be allowed to grow forever - so there needs to be a procedure for occasionally garbage collecting the clocks in a safe manner to balance fault tolerance with storage requirements.</p>
<h3>Replica synchronization: gossip and Merkle trees</h3>
<p>Given that the Dynamo system design is tolerant of node failures and network partitions, it needs a way to deal with nodes rejoining the cluster after being partitioned, or when a failed node is replaced or partially recovered.</p>
<p>Replica synchronization is used to bring nodes up to date after a failure, and for periodically synchronizing replicas with each other.</p>
<p>Gossip is a probabilistic technique for synchronizing replicas. The pattern of communication (e.g. which node contacts which node) is not determined in advance. Instead, nodes have some probability <code>p</code> of attempting to synchronize with each other. Every <code>t</code> seconds, each node picks a node to communicate with. This provides an additional mechanism beyond the synchronous task (e.g. the partial quorum writes) which brings the replicas up to date.</p>
<p>Gossip is scalable, and has no single point of failure, but can only provide probabilistic guarantees.</p>
<p>In order to make the information exchange during replica synchronization efficient, Dynamo uses a technique called Merkle trees, which I will not cover in detail. The key idea is that a data store can be hashed at multiple different level of granularity: a hash representing the whole content, half the keys, a quarter of the keys and so on.</p>
<p>By maintaining this fairly granular hashing, nodes can compare their data store content much more efficiently than a naive technique. Once the nodes have identified which keys have different values, they exchange the necessary information to bring the replicas up to date.</p>
<h3>Dynamo in practice: probabilistically bounded staleness (PBS)</h3>
<p>And that pretty much covers the Dynamo system design:</p>
<ul class="list">
<li>consistent hashing to determine key placement</li>
<li>partial quorums for reading and writing</li>
<li>conflict detection and read repair via vector clocks and</li>
<li>gossip for replica synchronization</li>
</ul>
<p>How might we characterize the behavior of such a system? A fairly recent paper from Bailis et al. (2012) describes an approach called <a href="http://pbs.cs.berkeley.edu/">PBS</a> (probabilistically bounded staleness) uses simulation and data collected from a real world system to characterize the expected behavior of such a system.</p>
<p>PBS estimates the degree of inconsistency by using information about the anti-entropy (gossip) rate, the network latency and local processing delay to estimate the expected level of consistency of reads. It has been implemented in Cassandra, where timing information is piggybacked on other messages and an estimate is calculated based on a sample of this information in a Monte Carlo simulation.</p>
<p>Based on the paper, during normal operation eventually consistent data stores are often faster and can read a consistent state within tens or hundreds of milliseconds. The table below illustrates amount of time required from a 99.9% probability of consistent reads given different <code>R</code> and <code>W</code> settings on empirical timing data from LinkedIn (SSD and 15k RPM disks) and Yammer:</p>
<p class="img-container"><img src="./images/pbs.png" alt="from the PBS paper"></p>
<p>For example, going from <code>R=1</code>, <code>W=1</code> to <code>R=2</code>, <code>W=1</code> in the Yammer case reduces the inconsistency window from 1352 ms to 202 ms - while keeping the read latencies lower (32.6 ms) than the fastest strict quorum (<code>R=3</code>, <code>W=1</code>; 219.27 ms).</p>
<p>For more details, have a look at the <a href="http://pbs.cs.berkeley.edu/">PBS website</a>  and the associated paper.</p>
<h2>Disorderly programming</h2>
<p>Let&#39;s look back at the examples of the kinds of situations that we&#39;d like to resolve. The first scenario consisted of three different servers behind partitions; after the partitions healed, we wanted the servers to converge to the same value. Amazon&#39;s Dynamo made this possible by reading from <code>R</code> out of <code>N</code> nodes and then performing read reconciliation.</p>
<p>In the second example, we considered a more specific operation: string concatenation. It turns out that there is no known technique for making string concatenation resolve to the same value without imposing an order on the operations (e.g. without expensive coordination). However, there are operations which can be applied safely in any order, where a simple register would not be able to do so. As Pat Helland wrote:</p>
<blockquote>
<p>... operation-centric work can be made commutative (with the right operations and the right semantics) where a simple READ/WRITE semantic does not lend itself to commutativity.</p>
</blockquote>
<p>For example, consider a system that implements a simple accounting system with the <code>debit</code> and <code>credit</code> operations in two different ways:</p>
<ul class="list">
<li>using a register with <code>read</code> and <code>write</code> operations, and</li>
<li>using a integer data type with native <code>debit</code> and <code>credit</code> operations</li>
</ul>
<p>The latter implementation knows more about the internals of the data type, and so it can preserve the intent of the operations in spite of the operations being reordered. Debiting or crediting can be applied in any order, and the end result is the same:</p>
<pre>100 + credit(10) + credit(20) = 130 and
100 + credit(20) + credit(10) = 130</pre>
<p> However, writing a fixed value cannot be done in any order: if writes are reordered, the one of the writes will overwrite the other:</p>
<pre>100 + write(110) + write(130) = 130 but
100 + write(130) + write(110) = 110</pre>
<p>Let&#39;s take the example from the beginning of this chapter, but use a different operation. In this scenario, clients are sending messages to two nodes, which see the operations in different orders:</p>
<pre>[Clients]  --&gt; [A]  1, 2, 3
[Clients]  --&gt; [B]  2, 3, 1</pre>
<p>Instead of string concatenation, assume that we are looking to find the largest value (e.g. MAX()) for a set of integers. The messages 1, 2 and 3 are:</p>
<pre>1: { operation: max(previous, 3) }
2: { operation: max(previous, 5) }
3: { operation: max(previous, 7) }</pre>
<p>Then, without coordination, both A and B will converge to 7, e.g.:</p>
<pre>A: max(max(max(0, 3), 5), 7) = 7
B: max(max(max(0, 5), 7), 3) = 7</pre>
<p>In both cases, two replicas see updates in different order, but we are able to merge the results in a way that has the same result in spite of what the order is. The result converges to the same answer in both cases because of the merge procedure (<code>max</code>) we used.</p>
<p>It is likely not possible to write a merge procedure that works for all data types. In Dynamo, a value is a binary blob, so the best that can be done is to expose it and ask the application to handle each conflict.</p>
<p>However, if we know that the data is of a more specific type, handling these kinds of conflicts becomes possible. CRDT&#39;s are data structures designed to provide data types that will always converge, as long as they see the same set of operations (in any order).</p>
<h2>CRDTs: Convergent replicated data types</h2>
<p>CRDTs (convergent replicated datatypes) exploit knowledge regarding the commutativity and associativity of specific operations on specific datatypes.</p>
<p>In order for a set of operations to converge on the same value in an environment where replicas only communicate occasionally, the operations need to be order-independent and insensitive to (message) duplication/redelivery. Thus, their operations need to be:</p>
<ul class="list">
<li>Associative (<code>a+(b+c)=(a+b)+c</code>), so that grouping doesn&#39;t matter</li>
<li>Commutative (<code>a+b=b+a</code>), so that order of application doesn&#39;t matter</li>
<li>Idempotent (<code>a+a=a</code>), so that duplication does not matter</li>
</ul>
<p>It turns out that these structures are already known in mathematics; they are known as join or meet <a href="http://en.wikipedia.org/wiki/Semilattice">semilattices</a>.</p>
<p>A <a href="http://en.wikipedia.org/wiki/Lattice_%28order%29">lattice</a> is a partially ordered set with a distinct top (least upper bound) and a distinct bottom (greatest lower bound). A semilattice is like a lattice, but one that only has a distinct top or bottom. A join semilattice is one with a distinct top (least upper bound) and a meet semilattice is one with a distinct bottom (greatest lower bound).</p>
<p>Any data type that be expressed as a semilattice can be implemented as a data structure which guarantees convergence. For example, calculating the <code>max()</code> of a set of values will always return the same result regardless of the order in which the values were received, as long as all values are eventually received, because the <code>max()</code> operation is associative, commutative and idempotent.</p>
<p>For example, here are two lattices: one drawn for a set, where the merge operator is <code>union(items)</code> and one drawn for a strictly increasing integer counter, where the merge operator is <code>max(values)</code>:</p>
<pre>   { a, b, c }              7
  /      |    \            /  \
{a, b} {b,c} {a,c}        5    7
  |  \  /  | /           /   |  \
  {a} {b} {c}            3   5   7</pre>
<p>With data types that can be expressed as semilattices, you can have replicas communicate in any pattern and receive the updates in any order, and they will eventually agree on the end result as long as they all see the same information. That is a powerful property that can be guaranteed as long as the prerequisites hold.</p>
<p>However, expressing a data type as a semilattice often requires some level of interpretation. Many data types have operations which are not in fact order-independent. For example, adding items to a set is associative, commutative and idempotent. However, if we also allow items to be removed from a set, then we need some way to resolve conflicting operations, such as <code>add(A)</code> and <code>remove(A)</code>. What does it mean to remove an element if the local replica never added it? This resolution has to be specified in a manner that is order-independent, and there are several different choices with different tradeoffs.</p>
<p>This means that several familiar data types have more specialized implementations as CRDT&#39;s which make a different tradeoff in order to resolve conflicts in an order-independent manner. Unlike a key-value store which simply deals with registers (e.g. values that are opaque blobs from the perspective of the system), someone using CRDTs must use the right data type to avoid anomalies.</p>
<p>Some examples of the different data types specified as CRDT&#39;s include:</p>
<ul class="list">
<li>Counters<ul class="list">
<li>Grow-only counter (merge = max(values); payload = single integer)</li>
<li>Positive-negative counter (consists of two grow counters, one for increments and another for decrements)</li>
</ul>
</li>
<li>Registers<ul class="list">
<li>Last Write Wins -register (timestamps or version numbers; merge = max(ts); payload = blob)</li>
<li>Multi-valued -register (vector clocks; merge = take both)</li>
</ul>
</li>
<li>Sets<ul class="list">
<li>Grow-only set (merge = union(items); payload = set; no removal)</li>
<li>Two-phase set (consists of two sets, one for adding, and another for removing; elements can be added once and removed once)</li>
<li>Unique set (an optimized version of the two-phase set)</li>
<li>Last write wins set (merge = max(ts); payload = set)</li>
<li>Positive-negative set (consists of one PN-counter per set item)</li>
<li>Observed-remove set</li>
</ul>
</li>
<li>Graphs and text sequences (see the paper)</li>
</ul>
<p>To ensure anomaly-free operation, you need to find the right data type for your specific application - for example, if you know that you will only remove an item once, then a two-phase set works; if you will only ever add items to a set and never remove them, then a grow-only set works.</p>
<p>Not all data structures have known implementations as CRDTs, but there are CRDT implementations for booleans, counters, sets, registers and graphs in the recent (2011) <a href="http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf">survey paper from Shapiro et al</a>.</p>
<p>Interestingly, the register implementations correspond directly with the implementations that key value stores use: a last-write-wins register uses timestamps or some equivalent and simply converges to the largest timestamp value; a multi-valued register corresponds to the Dynamo strategy of retaining, exposing and reconciling concurrent changes. For the details, I recommend that you take a look at the papers in the further reading section of this chapter.</p>
<h2>The CALM theorem</h2>
<p>The CRDT data structures were based on the recognition that data structures expressible as semilattices are convergent. But programming is about more than just evolving state, unless you are just implementing a data store.</p>
<p>Clearly, order-independence is an important property of any computation that converges: if the order in which data items are received influences the result of the computation, then there is no way to execute a computation without guaranteeing order.</p>
<p>However, there are many programming models in which the order of statements does not play a significant role. For example, in the <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce model</a>, both the Map and the Reduce tasks are specified as stateless tuple-processing tasks that need to be run on a dataset. Concrete decisions about how and in what order data is routed to the tasks is not specified explicitly, instead, the batch job scheduler is responsible for scheduling the tasks to run on the cluster.</p>
<p>Similarly, in SQL one specifies the query, but not how the query is executed. The query is simply a declarative description of the task, and it is the job of the query optimizer to figure out an efficient way to execute the query (across multiple machines, databases and tables).</p>
<p>Of course, these programming models are not as permissive as a general purpose programming language. MapReduce tasks need to be expressible as stateless tasks in an acyclic dataflow program; SQL statements can execute fairly sophisticated computations but many things are hard to express in it.</p>
<p>However, it should be clear from these two examples that there are many kinds of data processing tasks which are amenable to being expressed in a declarative language where the order of execution is not explicitly specified. Programming models which express a desired result while leaving the exact order of statements up to an optimizer to decide often have semantics that are order-independent. This means that such programs may be possible to execute without coordination, since they depend on the inputs they receive but not necessarily the specific order in which the inputs are received.</p>
<p>The key point is that such programs <em>may be</em> safe to execute without coordination. Without a clear rule that characterizes what is safe to execute without coordination, and what is not, we cannot implement a program while remaining certain that the result is correct.</p>
<p>This is what the CALM theorem is about. The CALM theorem is based on a recognition of the link between logical monotonicity and useful forms of eventual consistency (e.g. confluence / convergence). It states that logically monotonic programs are guaranteed to be eventually consistent.</p>
<p>Then, if we know that some computation is logically monotonic, then we know that it is also safe to execute without coordination.</p>
<p>To better understand this, we need to contrast monotonic logic (or monotonic computations) with <a href="http://plato.stanford.edu/entries/logic-nonmonotonic/">non-monotonic logic</a> (or non-monotonic computations).</p>
<dl>
  <dt>Monotony</dt>
  <dd>if sentence <code>Ï</code> is a consequence of a set of premises <code>Î</code>, then it can also be inferred from any set <code>Î</code> of premises extending <code>Î</code></dd>
</dl>

<p>Most standard logical frameworks are monotonic: any inferences made within a framework such as first-order logic, once deductively valid, cannot be invalidated by new information. A non-monotonic logic is a system in which that property does not hold - in other words, if some conclusions can be invalidated by learning new knowledge.</p>
<p>Within the artificial intelligence community, non-monotonic logics are associated with <a href="http://plato.stanford.edu/entries/reasoning-defeasible/">defeasible reasoning</a> - reasoning, in which assertions made utilizing partial information can be invalidated by new knowledge. For example, if we learn that Tweety is a bird, we&#39;ll assume that Tweety can fly; but if we later learn that Tweety is a penguin, then we&#39;ll have to revise our conclusion.</p>
<p>Monotonicity concerns the relationship between premises (or facts about the world) and conclusions (or assertions about the world). Within a monotonic logic, we know that our results are retraction-free: <a href="http://en.wikipedia.org/wiki/Monotonicity_of_entailment">monotone</a> computations do not need to be recomputed or coordinated; the answer gets more accurate over time. Once we know that Tweety is a bird (and that we&#39;re reasoning using monotonic logic), we can safely conclude that Tweety can fly and that nothing we learn can invalidate that conclusion.</p>
<p>While any computation that produces a human-facing result can be interpreted as an assertion about the world (e.g. the value of &quot;foo&quot; is &quot;bar&quot;), determining whether a computation in a von Neumann -machine based programming model is monotonic difficult because it is not exactly clear what the relationship between facts and assertions are and whether those relationships are monotonic.</p>
<p>However, there are a number of programming models for which determining monotonicity is possible. In particular, <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> (e.g. the theoretical underpinnings of SQL) and <a href="http://en.wikipedia.org/wiki/Datalog">Datalog</a> provide highly expressive languages that have well-understood interpretations.</p>
<p>Both basic Datalog and relational algebra (even with recursion) are known to be monotonic. More specifically, computations expressed using a certain set of basic operators are known to be monotonic (selection, projection, natural join, cross product, union and recursive Datalog without negation), and non-monotonicity is introduced by using more advanced operators (negation, set difference, division, universal quantification, aggregation).</p>
<p>This means that computations expressed using a significant number of operators (e.g. map, filter, join, union, intersection) in those systems are logically monotonic; any computations using those operators are also monotonic and thus safe to run without coordination. Expressions that make use of negation and aggregation, on the other hand, are not safe to run without coordination.</p>
<p>It is important to realize the connection between non-monotonicity and operations that are expensive to perform in a distributed system. Specifically, both <em>distributed aggregation</em> and <em>coordination protocols</em> can be considered to be a form of negation. As Joe Hellerstein <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf">writes</a>:</p>
<blockquote>
<p>To establish the veracity of a negated predicate in a distributed setting, an evaluation strategy has to start &quot;counting to 0&quot; to determine emptiness, and wait until the distributed counting process has definitely terminated. Aggregation is the generalization of this idea.</p>
</blockquote>
<p>and:</p>
<blockquote>
<p>This idea can be seen from the other direction as well. Coordination protocols are themselves aggregations, since they entail voting: Two-Phase Commit requires unanimous votes, Paxos consensus requires majority votes, and Byzantine protocols require a 2/3 majority. Waiting requires counting.</p>
</blockquote>
<p>If, then we can express our computation in a manner in which it is possible to test for monotonicity, then we can perform a whole-program static analysis that detects which parts of the program are eventually consistent and safe to run without coordination (the monotonic parts) - and which parts are not (the non-monotonic ones).</p>
<p>Note that this requires a different kind of language, since these inferences are hard to make for traditional programming languages where sequence, selection and iteration are at the core. Which is why the Bloom language was designed.</p>
<h2>What is non-mononicity good for?</h2>
<p>The difference between monotonicity and non-monotonicity is interesting. For example, adding two numbers is monotonic, but calculating an aggregation over two nodes containing numbers is not. What&#39;s the difference? One of these is a computation (adding two numbers), while the other is an assertion (calculating an aggregate).</p>
<p>How does a computation differ from an assertion? Let&#39;s consider the query &quot;is pizza a vegetable?&quot;. To answer that, we need to get at the core: when is it acceptable to infer that something is (or is not) true?</p>
<p>There are several acceptable answers, each corresponding to a different set of assumptions regarding the information that we have and the way we ought to act upon it - and we&#39;ve come to accept different answers in different contexts.</p>
<p>In everyday reasoning, we make what is known as the <a href="http://en.wikipedia.org/wiki/Open_world_assumption">open-world assumption</a>: we assume that we do not know everything, and hence cannot make conclusions from a lack of knowledge. That is, any sentence may be true, false or unknown.</p>
<pre>                                OWA +             |  OWA +
                                Monotonic logic   |  Non-monotonic logic
Can derive P(true)      |   Can assert P(true)    |  Cannot assert P(true)
Can derive P(false)     |   Can assert P(false)   |  Cannot assert P(true)
Cannot derive P(true)   |   Unknown               |  Unknown
or P(false)</pre>
<p>When making the open world assumption, we can only safely assert something we can deduce from what is known. Our information about the world is assumed to be incomplete.</p>
<p>Let&#39;s first look at the case where we know our reasoning is monotonic. In this case, any (potentially incomplete) knowledge that we have cannot be invalidated by learning new knowledge. So if we can infer that a sentence is true based on some deduction, such as &quot;things that contain two tablespoons of tomato paste are vegetables&quot; and &quot;pizza contains two tablespoons of tomato paste&quot;, then we can conclude that &quot;pizza is a vegetable&quot;. The same goes for if we can deduce that a sentence is false.</p>
<p>However, if we cannot deduce anything - for example, the set of knowledge we have contains customer information and nothing about pizza or vegetables - then under the open world assumption we have to say that we cannot conclude anything.</p>
<p>With non-monotonic knowledge, anything we know right now can potentially be invalidated. Hence, we cannot safely conclude anything, even if we can deduce true or false from what we currently know.</p>
<p>However, within the database context, and within many computer science applications we prefer to make more definite conclusions. This means assuming what is known as the <a href="http://en.wikipedia.org/wiki/Closed_world_assumption">closed-world assumption</a>: that anything that cannot be shown to be true is false. This means that no explicit declaration of falsehood is needed. In other words, the database of facts that we have is assumed to be complete (minimal), so that anything not in it can be assumed to be false.</p>
<p>For example, under the CWA, if our database does not have an entry for a flight between San Francisco and Helsinki, then we can safely conclude that no such flight exists.</p>
<p>We need one more thing to be able to make definite assertions: <a href="http://en.wikipedia.org/wiki/Circumscription_%28logic%29">logical circumscription</a>. Circumscription is a formalized rule of conjecture. Domain circumscription conjectures that the known entities are all there are. We need to be able to assume that the known entities are all there are in order to reach a definite conclusion.</p>
<pre>                                CWA +             |  CWA +
                                Circumscription + |  Circumscription +
                                Monotonic logic   |  Non-monotonic logic
Can derive P(true)      |   Can assert P(true)    |  Can assert P(true)
Can derive P(false)     |   Can assert P(false)   |  Can assert P(false)
Cannot derive P(true)   |   Can assert P(false)   |  Can assert P(false)
or P(false)</pre>
<p>In particular, non-monotonic inferences need this assumption. We can only make a confident assertion if we assume that we have complete information, since additional information may otherwise invalidate our assertion.</p>
<p>What does this mean in practice? First, monotonic logic can reach definite conclusions as soon as it can derive that a sentence is true (or false). Second, nonmonotonic logic requires an additional assumption: that the known entities are all there is.</p>
<p>So why are two operations that are on the surface equivalent different? Why is adding two numbers monotonic, but calculating an aggregation over two nodes not? Because the aggregation does not only calculate a sum but also asserts that it has seen all of the values. And the only way to guarantee that is to coordinate across nodes and ensure that the node performing the calculation has really seen all of the values within the system.</p>
<p>Thus, in order to handle nonmonotonicity one needs to either use distributed coordination to ensure that assertions are made only after all the information is known or make assertions with the caveat that the conclusion can be invalidated later on.</p>
<p>Handling non-monotonicity is important for reasons of expressiveness. This comes down to being able to express non-monotone things; for example, it is nice to be able to say that the total of some column is X. The system must detect that this kind of computation  requires a global coordination boundary to ensure that we have seen all the entities.</p>
<p>Purely monotone systems are rare. It seems that most applications operate under the closed-world assumption even when they have incomplete data, and we humans are fine with that. When a database tells you that a direct flight between San Francisco and Helsinki does not exist, you will probably treat this as &quot;according to this database, there is no direct flight&quot;, but you do not rule out the possibility that that in reality such a flight might still exist.</p>
<p>Really, this issue only becomes interesting when replicas can diverge (e.g. during a partition or due to delays during normal operation). Then there is a need for a more specific consideration: whether the answer is based on just the current node, or the totality of the system.</p>
<p>Further, since nonmonotonicity is caused by making an assertion, it seems plausible that many computations can proceed for a long time and only apply coordination at the point where some result or assertion is passed to a 3rd party system or end user. Certainly it is not necessary for every single read and write operation within a system to enforce a total order, if those reads and writes are simply a part of a long running computation.</p>
<h2>The Bloom language</h2>
<p>The <a href="http://www.bloom-lang.net/">Bloom language</a> is a language designed to make use of the CALM theorem. It is a Ruby DSL which has its formal basis in a temporal logic programming language called Dedalus.</p>
<p>In Bloom, each node has a database consisting of collections and lattices. Programs are expressed as sets of unordered statements which interact with collections (sets of facts) and lattices (CRDTs). Statements are order-independent by default, but one can also write non-monotonic functions.</p>
<p>Have a look at the <a href="http://www.bloom-lang.net/">Bloom website</a> and <a href="https://github.com/bloom-lang/bud/tree/master/docs">tutorials</a> to learn more about Bloom.</p>
<hr>
<h2>Further reading</h2>
<h4>The CALM theorem, confluence analysis and Bloom</h4>
<p><a href="http://vimeo.com/53904989">Joe Hellerstein&#39;s talk @RICON 2012</a> is a good introduction to the topic, as is <a href="http://vimeo.com/45111940">Neil Conway&#39;s talk @Basho</a>. For Bloom in particular, see <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/Bloom-Disorderly-Programming-for-a-Distributed-World">Peter Alvaro&#39;s talk@Microsoft</a>.</p>
<ul class="list">
<li><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf">The Declarative Imperative: Experiences and Conjectures in Distributed Logic</a> - Hellerstein, 2010</li>
<li><a href="http://db.cs.berkeley.edu/papers/cidr11-bloom.pdf">Consistency Analysis in Bloom: a CALM and Collected Approach</a> - Alvaro et al., 2011</li>
<li><a href="http://db.cs.berkeley.edu/papers/UCB-lattice-tr.pdf">Logic and Lattices for Distributed Programming</a> - Conway et al., 2012</li>
<li><a href="http://db.cs.berkeley.edu/papers/datalog2011-dedalus.pdf">Dedalus: Datalog in Time and Space</a> - Alvaro et al., 2011</li>
</ul>
<h4>CRDTs</h4>
<p><a href="http://research.microsoft.com/apps/video/dl.aspx?id=153540">Marc Shapiro&#39;s talk @ Microsoft</a> is a good starting point for understanding CRDT&#39;s.</p>
<ul class="list">
<li><a href="http://hal.archives-ouvertes.fr/docs/00/39/79/81/PDF/RR-6956.pdf">CRDTs: Consistency Without Concurrency Control</a> - Letitia et al., 2009</li>
<li><a href="http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>, Shapiro et al., 2011</li>
<li><a href="http://arxiv.org/pdf/1210.3368v1.pdf">An Optimized conflict-free Replicated Set</a> - Bieniusa et al., 2012</li>
</ul>
<h4>Dynamo; PBS; optimistic replication</h4>
<ul class="list">
<li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo: Amazonâs Highly Available Key-value Store</a> - DeCandia et al., 2007</li>
<li><a href="http://scholar.google.com/scholar?q=PNUTS:+Yahoo!&#39;s+Hosted+Data+Serving+Platform">PNUTS: Yahoo!&#39;s Hosted Data Serving Platform</a> - Cooper et al., 2008</li>
<li><a href="http://scholar.google.com/scholar?q=The+Bayou+Architecture%3A+Support+for+Data+Sharing+among+Mobile+Users">The Bayou Architecture: Support for Data Sharing among Mobile Users</a> - Demers et al. 1994</li>
<li><a href="http://pbs.cs.berkeley.edu/pbs-vldb2012.pdf">Probabilistically Bound Staleness for Practical Partial Quorums</a> - Bailis et al., 2012</li>
<li><a href="https://queue.acm.org/detail.cfm?id=2462076">Eventual Consistency Today: Limitations, Extensions, and Beyond</a> - Bailis &amp; Ghodsi, 2013</li>
<li><a href="http://www.ysaito.com/survey.pdf">Optimistic replication</a> - Saito &amp; Shapiro, 2005</li>
</ul>
<div style="page-break-after: always;"></div><a name="appendix"></a><h1>6. Further reading and appendix</h1>
<p>If you&#39;ve made it this far, thank you.</p>
<p>If you liked the book, follow me on <a href="https://github.com/mixu/">Github</a> (or <a href="http://twitter.com/mikitotakada">Twitter</a>). I love seeing that I&#39;ve had some kind of positive impact. &quot;Create more value than you capture&quot; and all that.</p>
<p>I&#39;d like to thank @logpath and @alexras for their comments - of course, any mistakes and omissions that remain are my fault!</p>
<p>It&#39;s worth noting that my chapter on eventual consistency is fairly Berkeley-centric; I&#39;d like to change that. I&#39;ve also skipped one prominent use case for time: consistent snapshots. There are also a couple of topics which I should expand on: namely, an explicit discussion of safety and liveness properties and a more detailed discussion of consistent hashing. However, I&#39;m off to <a href="https://thestrangeloop.com/">Strange Loop 2013</a>, so whatever.</p>
<p>If this book had a chapter 6, it would probably be about the ways in which one can make use of and deal with large amounts of data. It seems that the most common type of &quot;big data&quot; computation is one in which <a href="http://en.wikipedia.org/wiki/SPMD">a large dataset is passed through a single simple program</a>. I&#39;m not sure what the subsequent chapters would be (perhaps high performance computing, given that the current focus has been on feasibility), but I&#39;ll probably know in a couple of years.</p>
<h2>Books about distributed systems</h2>
<h4>Distributed Algorithms (Lynch)</h4>
<p>This is probably the most frequently recommended book on distributed algorithms. I&#39;d also recommend it, but with a caveat. It is very comprehensive, but written for a graduate student audience, so you&#39;ll spend a lot of time reading about synchronous systems and shared memory algorithms before getting to things that are most interesting to a practitioner.</p>
<h4>Introduction to Reliable and Secure Distributed Programming (Cachin, Guerraoui &amp; Rodrigues)</h4>
<p>For a practitioner, this is a fun one. It&#39;s short and full of actual algorithm implementations.</p>
<h4>Replication: Theory and Practice</h4>
<p>If you&#39;re interested in replication, this book is amazing. The chapter on replication is largely based on a synthesis of the interesting parts of this book plus more recent readings.</p>
<h4>Distributed Systems: An Algorithmic Approach (Ghosh)</h4>
<h4>Introduction to Distributed Algorithms (Tel)</h4>
<h4>Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control and Recovery (Weikum &amp; Vossen)</h4>
<p>This book is on traditional transactional information systems, e.g. local RDBMS&#39;s. There are two chapters on distributed transactions at the end, but the focus of the book is on transaction processing.</p>
<h4>Transaction Processing: Concepts and Techniques by Gray and Reuter</h4>
<p>A classic. I find that Weikum &amp; Vossen is more up to date.</p>
<h2>Seminal papers</h2>
<p>Each year, the <a href="http://en.wikipedia.org/wiki/Dijkstra_Prize">Edsger W. Dijkstra Prize in Distributed Computing</a> is given to outstanding papers on the principles of distributed computing. Check out the link for the full list, which includes classics such as:</p>
<ul class="list">
<li>&quot;<a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">Time, Clocks and Ordering of Events in a Distributed System</a>&quot; - Leslie Lamport</li>
<li>&quot;<a href="http://theory.lcs.mit.edu/tds/papers/Lynch/jacm85.pdf">Impossibility of Distributed Consensus With One Faulty Process</a>&quot; - Fisher, Lynch, Patterson</li>
<li>&quot;<a href="http://scholar.google.com/scholar?q=Unreliable+Failure+Detectors+for+Reliable+Distributed+Systems">Unreliable failure detectors and reliable distributed systems</a>&quot; - Chandra and Toueg</li>
</ul>
<p>Microsoft Academic Search has a list of <a href="http://libra.msra.cn/RankList?entitytype=1&amp;topDomainID=2&amp;subDomainID=16&amp;last=0&amp;start=1&amp;end=100">top publications in distributed &amp; parallel computing ordered by number of citations</a> - this may be an interesting list to skim for more classics.</p>
<p>Here are some additional lists of recommended papers:</p>
<ul class="list">
<li><a href="http://courses.csail.mit.edu/6.852/08/handouts/handout3.pdf">Nancy Lynch&#39;s recommended reading list</a> from her course on Distributed systems.</li>
<li><a href="http://nosqlsummer.org/papers">NoSQL Summer paper list</a> - a curated list of papers related to this buzzword.</li>
<li><a href="http://www.quora.com/What-are-the-seminal-papers-in-distributed-systems-Why">A Quora question on seminal papers in distributed systems</a>.</li>
</ul>
<h3>Systems</h3>
<ul class="list">
<li><a href="http://research.google.com/archive/gfs.html">The Google File System</a> - Ghemawat, Gobioff and Leung</li>
<li><a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a> - Dean and Ghemawat</li>
<li><a href="http://scholar.google.com/scholar?q=Dynamo%3A+Amazon&#39;s+Highly+Available+Key-value+Store">Dynamo: Amazonâs Highly Available Key-value Store</a> - DeCandia et al.</li>
<li><a href="http://research.google.com/archive/bigtable.html">Bigtable: A Distributed Storage System for Structured Data</a> - Chang et al.</li>
<li><a href="http://research.google.com/archive/chubby.html">The Chubby Lock Service for Loosely-Coupled Distributed Systems</a> - Burrows</li>
<li><a href="http://research.yahoo.com/pub/3280">ZooKeeper: Wait-free coordination for Internet-scale systems</a></li>
</ul>

        </div>


      </div>


    <div class="clear">
      <hr>
    </div>

    <div class="header nav">
      <p><a href="index.html">Previous Chapter</a> | <a href="index.html">Home</a> | <a href="index.html">Next Chapter</a></p>
    </div>

    <div class="clear">
      <hr>
    </div>

    <div class="header nav">
      <p>"Distributed systems: for fun and profit" by <a href="http://mixu.net/">Mikito Takada</a>.</p>
    </div>

    <div class="clear">
      <hr>
    </div>

    <div class="header nav">

      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'mixuds'; // required: replace example with your forum shortname

          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>



    </div>
  </div>


  </div>
</body>
</html>
